/// Encrypted Media Extensions
///
/// https://w3c.github.io/encrypted-media/
@JS('window')
@staticInterop
library encrypted_media;

import 'package:js/js.dart';

import 'dart:typed_data';
import 'callbacks.dart';
import '../manual.dart';
import 'all_bindings.dart';
/* deps: html
dom */

enum MediaKeysRequirement { valueRequired, optional, notAllowed }

@anonymous
@JS()
@staticInterop
class MediaKeySystemConfiguration {
  external factory MediaKeySystemConfiguration(
      {String label = '',
      Iterable<String> initDataTypes = const [],
      Iterable<MediaKeySystemMediaCapability> audioCapabilities = const [],
      Iterable<MediaKeySystemMediaCapability> videoCapabilities = const [],
      MediaKeysRequirement distinctiveIdentifier =
          MediaKeysRequirement.optional,
      MediaKeysRequirement persistentState = MediaKeysRequirement.optional,
      Iterable<String> sessionTypes});
}

extension PropsMediaKeySystemConfiguration on MediaKeySystemConfiguration {
  external String get label;
  external set label(String newValue);
  external Iterable<String> get initDataTypes;
  external set initDataTypes(Iterable<String> newValue);
  external Iterable<MediaKeySystemMediaCapability> get audioCapabilities;
  external set audioCapabilities(
      Iterable<MediaKeySystemMediaCapability> newValue);
  external Iterable<MediaKeySystemMediaCapability> get videoCapabilities;
  external set videoCapabilities(
      Iterable<MediaKeySystemMediaCapability> newValue);
  external MediaKeysRequirement get distinctiveIdentifier;
  external set distinctiveIdentifier(MediaKeysRequirement newValue);
  external MediaKeysRequirement get persistentState;
  external set persistentState(MediaKeysRequirement newValue);
  external Iterable<String> get sessionTypes;
  external set sessionTypes(Iterable<String> newValue);
}

@anonymous
@JS()
@staticInterop
class MediaKeySystemMediaCapability {
  external factory MediaKeySystemMediaCapability(
      {String contentType = '',
      String? encryptionScheme,
      String robustness = ''});
}

extension PropsMediaKeySystemMediaCapability on MediaKeySystemMediaCapability {
  external String get contentType;
  external set contentType(String newValue);
  external String? get encryptionScheme;
  external set encryptionScheme(String? newValue);
  external String get robustness;
  external set robustness(String newValue);
}

///  Experimental: This is an experimental technologyCheck the
/// Browser compatibility table carefully before using this in
/// production.
///  The interface of the EncryptedMediaExtensions API provides
/// access to a Key System for decryption and/or a content protection
/// provider. You can request an instance of this object using the
/// [Navigator.requestMediaKeySystemAccess()] method.
@JS()
@staticInterop
class MediaKeySystemAccess {
  external factory MediaKeySystemAccess();
}

extension PropsMediaKeySystemAccess on MediaKeySystemAccess {
  /// Returns a [DOMString] identifying the key system being used.
  ///
  external String get keySystem;

  ///  Returns an object with the supported combination of
  /// configuration options.
  ///
  /// var mediaKeySystemConfiguration = mediaKeySystemAccess.getConfiguration();
  ///
  external MediaKeySystemConfiguration getConfiguration();

  /// Returns a [Promise] that resolves to a new [MediaKeys] object.
  ///
  /// var mediaKeys = await mediaKeySystemAccess.createMediaKeys();
  ///
  external Promise<MediaKeys> createMediaKeys();
}

enum MediaKeySessionType { temporary, persistentLicense }

///  Experimental: This is an experimental technologyCheck the
/// Browser compatibility table carefully before using this in
/// production.
///  The interface of EncryptedMediaExtensions API represents a set
/// of keys that an associated [HTMLMediaElement] can use for
/// decryption of media data during playback.
@JS()
@staticInterop
class MediaKeys {
  external factory MediaKeys();
}

extension PropsMediaKeys on MediaKeys {
  ///  Returns a new [MediaKeySession] object, which represents a
  /// context for message exchange with a content decryption module
  /// (CDM).
  ///
  /// var mediaKeySessionObject = MediaKeys.createSession([MediaKeySessionType]);
  ///
  external MediaKeySession createSession(
      [MediaKeySessionType? sessionType = MediaKeySessionType.temporary]);

  ///  Returns a [Promise] to a server certificate to be used to
  /// encrypt messages to the license server.
  ///
  /// MediaKeys.setServerCertificate(serverCertificate).then(function() { /* ... */ });
  ///
  external Promise<bool> setServerCertificate(dynamic serverCertificate);
}

///  The interface of the EncryptedMediaExtensions API represents a
/// context for message exchange with a content decryption module
/// (CDM).
@JS()
@staticInterop
class MediaKeySession implements EventTarget {
  external factory MediaKeySession();
}

extension PropsMediaKeySession on MediaKeySession {
  ///  Contains a unique string generated by the CDM for the current
  /// media object and its associated keys or licenses.
  ///
  external String get sessionId;

  ///  The time after which the keys in the current session can no
  /// longer be used to decrypt media data, or [NaN] if no such time
  /// exists. This value is determined by the CDM and measured in
  /// milliseconds since January 1, 1970, UTC. This value may change
  /// during a session lifetime, such as when an action triggers the
  /// start of a window.
  ///
  external /* double | NaN */ dynamic get expiration;

  ///  Returns a [Promise] signaling when a [MediaKeySession] closes.
  /// This promise can only be fulfilled and is never rejected. Closing
  /// a session means that licenses and keys associated with it are no
  /// longer valid for decrypting media data.
  ///
  external Promise<Object> get closed;

  ///  Contains a reference to a read-only [MediaKeyStatusMap] of the
  /// current session's keys and their statuses.
  ///
  external MediaKeyStatusMap get keyStatuses;
  external EventHandlerNonNull? get onkeystatuseschange;
  external set onkeystatuseschange(EventHandlerNonNull? newValue);
  external EventHandlerNonNull? get onmessage;
  external set onmessage(EventHandlerNonNull? newValue);

  ///  Returns a [Promise] after generating a media request based on
  /// initialization data.
  ///
  /// mediaKeySession.generateRequest().then(function) { /* ... */ });
  ///
  external Promise<Object> generateRequest(
      String initDataType, dynamic initData);

  ///  Returns a [Promise] that resolves to a boolean value after
  /// loading data for a specified session object.
  ///
  /// mediaKeySession.load(sessionId).then(function(booleanValue) { /* ... */ });
  ///
  external Promise<bool> load(String sessionId);

  ///  Returns a [Promise] after loading messages and licenses to the
  /// CDM.
  ///
  /// mediaKeySession.update(response).then(function() { /* ... */ });
  ///
  external Promise<Object> update(dynamic response);

  ///  Returns a [Promise] after notifying the current media session is
  /// no longer needed and that the CDM should release any resources
  /// associated with this object and close it.
  ///
  /// mediaKeySession.close().then(function() { /* ... */ });
  ///
  external Promise<Object> close();

  ///  Returns a [Promise] after removing any session data associated
  /// with the current object.
  ///
  external Promise<Object> remove();
}

///  Experimental: This is an experimental technologyCheck the
/// Browser compatibility table carefully before using this in
/// production.
///  The interface of the EncryptedMediaExtensions API is a read-only
/// map of media key statuses by key IDs.
@JS()
@staticInterop
class MediaKeyStatusMap {
  external factory MediaKeyStatusMap();
}

extension PropsMediaKeyStatusMap on MediaKeyStatusMap {
  /// Returns the number of key/value pars in the status map.
  ///
  external int get size;

  ///  Returns a boolean asserting whether a value has been associated
  /// with the given key.
  ///
  /// var boolean = mediaKeyStatusMap(key)
  ///
  external bool has(dynamic keyId);

  ///  Returns the value associated with the given key, or [undefined]
  /// if there is none.
  ///
  /// var value = mediaKeyStatusMap.get(key);
  ///
  @JS('get')
  @staticInterop
  external dynamic mGet(dynamic keyId);
}

enum MediaKeyStatus {
  usable,
  expired,
  released,
  outputRestricted,
  outputDownscaled,
  usableInFuture,
  statusPending,
  internalError
}

enum MediaKeyMessageType {
  licenseRequest,
  licenseRenewal,
  licenseRelease,
  individualizationRequest
}

///  Experimental: This is an experimental technologyCheck the
/// Browser compatibility table carefully before using this in
/// production.
///  The interface of the EncryptedMediaExtensions API contains the
/// content and related data when the content decryption module
/// generates a message for the session.
///
///
///
///    Event
///
///
///
///
///
///    MediaKeyMessageEvent
///
///
@JS()
@staticInterop
class MediaKeyMessageEvent implements Event {
  external factory MediaKeyMessageEvent(
      String type, MediaKeyMessageEventInit eventInitDict);
}

extension PropsMediaKeyMessageEvent on MediaKeyMessageEvent {
  ///  Indicates the type of message. May be one of [license-request],
  /// [license-renewal], [license-release], or
  /// [individualization-request].
  ///
  external MediaKeyMessageType get messageType;

  ///  Returns an [ArrayBuffer] with a message from the content
  /// decryption module. Messages vary by key system.
  ///
  external ByteBuffer get message;
}

@anonymous
@JS()
@staticInterop
class MediaKeyMessageEventInit implements EventInit {
  external factory MediaKeyMessageEventInit(
      {MediaKeyMessageType messageType, ByteBuffer message});
}

extension PropsMediaKeyMessageEventInit on MediaKeyMessageEventInit {
  external MediaKeyMessageType get messageType;
  external set messageType(MediaKeyMessageType newValue);
  external ByteBuffer get message;
  external set message(ByteBuffer newValue);
}

@JS()
@staticInterop
class MediaEncryptedEvent implements Event {
  external factory MediaEncryptedEvent(String type,
      [MediaEncryptedEventInit? eventInitDict]);
}

extension PropsMediaEncryptedEvent on MediaEncryptedEvent {
  external String get initDataType;
  external ByteBuffer? get initData;
}

@anonymous
@JS()
@staticInterop
class MediaEncryptedEventInit implements EventInit {
  external factory MediaEncryptedEventInit(
      {String initDataType = '', ByteBuffer? initData});
}

extension PropsMediaEncryptedEventInit on MediaEncryptedEventInit {
  external String get initDataType;
  external set initDataType(String newValue);
  external ByteBuffer? get initData;
  external set initData(ByteBuffer? newValue);
}
