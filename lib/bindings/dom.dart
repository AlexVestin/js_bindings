/// DOM Standard
///
/// https://dom.spec.whatwg.org/
@JS('window')
@staticInterop
library dom;

import 'package:js/js.dart';
import 'package:meta/meta.dart';
import 'dart:js_util' as js_util;

import 'callbacks.dart';
import '../manual.dart';
import 'all_bindings.dart';
/* deps: cssom_view_1
css_font_loading_3
dom
html
d_o_m_parsing
web_animations_1
wai_aria_1_2
css_regions_1
cssom_1
hr_time_3
page_visibility_2
css_typed_om_1
selection_api
geometry_1
fullscreen
css_pseudo_4
svg11
scroll_to_text_fragment
floc
permissions_policy_1
css_nav_1
font_metrics_api_1 */

/// The interface represents an event which takes place in the DOM.
///  An event can be triggered by the user action e.g. clicking the
/// mouse button or tapping keyboard, or generated by APIs to
/// represent the progress of an asynchronous task. It can also be
/// triggered programmatically, such as by calling the
/// [HTMLElement.click()] method of an element, or by defining the
/// event, then sending it to a specified target using
/// [EventTarget.dispatchEvent()].
///  There are many types of events, some of which use other
/// interfaces based on the main interface. itself contains the
/// properties and methods which are common to all events.
///  Many DOM elements can be set up to accept (or "listen" for)
/// these events, and execute code in response to process (or
/// "handle") them. Event-handlers are usually connected (or
/// "attached") to various HTML elements (such as [<button>],
/// [<div>], [<span>], etc.) using [EventTarget.addEventListener()],
/// and this generally replaces using the old HTML event handler
/// attributes. Further, when properly added, such handlers can also
/// be disconnected if needed using [removeEventListener()].
///
///   Note: One element can have several such handlers, even for the
/// exact same event—particularly if separate, independent code
/// modules attach them, each for its own independent purposes. (For
/// example, a webpage with an advertising-module and
/// statistics-module both monitoring video-watching.)
///
///  When there are many nested elements, each with its own
/// handler(s), event processing can become very
/// complicated—especially where a parent element receives the very
/// same event as its child elements because "spatially" they overlap
/// so the event technically occurs in both, and the processing order
/// of such events depends on the Event bubbling and capture settings
/// of each handler triggered.
@JS()
@staticInterop
class Event {
  external factory Event(String type, [EventInit? eventInitDict]);
  external static int get NONE;
  external static int get CAPTURING_PHASE;
  external static int get AT_TARGET;
  external static int get BUBBLING_PHASE;
}

extension PropsEvent on Event {
  /// The case-insensitive name identifying the type of the event.
  ///
  external String get type;

  ///  A reference to the object to which the event was originally
  /// dispatched.
  ///
  external EventTarget? get target;
  external EventTarget? get srcElement;

  ///  A reference to the currently registered target for the event.
  /// This is the object to which the event is currently slated to be
  /// sent. It's possible this has been changed along the way through
  /// retargeting.
  ///
  external EventTarget? get currentTarget;

  ///  Returns the event's path (an array of objects on which listeners
  /// will be invoked). This does not include nodes in shadow trees if
  /// the shadow root was created with its [ShadowRoot.mode] closed.
  ///
  /// var composed = Event.composedPath();
  ///
  external Iterable<EventTarget> composedPath();

  ///  Indicates which phase of the event flow is being processed. It
  /// is one of the following numbers: [NONE], [CAPTURING_PHASE],
  /// [AT_TARGET], [BUBBLING_PHASE].
  ///
  external int get eventPhase;

  /// Stops the propagation of events further along in the DOM.
  ///
  /// event.stopPropagation();
  ///
  external Object stopPropagation();
  external bool get cancelBubble;
  external set cancelBubble(bool newValue);

  ///  For this particular event, prevent all other listeners from
  /// being called. This includes listeners attached to the same
  /// element as well as those attached to elements that will be
  /// traversed later (during the capture phase, for instance).
  ///
  /// event.stopImmediatePropagation();
  ///
  external Object stopImmediatePropagation();

  ///  A boolean value indicating whether or not the event bubbles up
  /// through the DOM.
  ///
  external bool get bubbles;

  /// A boolean value indicating whether the event is cancelable.
  ///
  external bool get cancelable;
  external dynamic get returnValue;
  external set returnValue(dynamic newValue);

  /// Cancels the event (if it is cancelable).
  ///
  /// event.preventDefault();
  ///
  external Object preventDefault();

  ///  Indicates whether or not the call to [event.preventDefault()]
  /// canceled the event.
  ///
  external bool get defaultPrevented;

  ///  A boolean indicating whether or not the event can bubble across
  /// the boundary between the shadow DOM and the regular DOM.
  ///
  external bool get composed;

  ///  Indicates whether or not the event was initiated by the browser
  /// (after a user click, for instance) or by a script (using an event
  /// creation method, for example).
  ///
  external bool get isTrusted;

  ///  The time at which the event was created (in milliseconds). By
  /// specification, this value is time since epoch—but in reality,
  /// browsers' definitions vary. In addition, work is underway to
  /// change this to be a [DOMHighResTimeStamp] instead.
  ///
  external double get timeStamp;
  external Object initEvent(String type,
      [bool? bubbles = false, bool? cancelable = false]);
}

@anonymous
@JS()
@staticInterop
class EventInit {
  external factory EventInit(
      {bool bubbles = false, bool cancelable = false, bool composed = false});
}

extension PropsEventInit on EventInit {
  external bool get bubbles;
  external set bubbles(bool newValue);
  external bool get cancelable;
  external set cancelable(bool newValue);
  external bool get composed;
  external set composed(bool newValue);
}

///  The interface represents events initialized by an application
/// for any purpose.
///  Note: This feature is available in Web Workers
///
@JS()
@staticInterop
class CustomEvent implements Event {
  external factory CustomEvent(String type, [CustomEventInit? eventInitDict]);
}

extension PropsCustomEvent on CustomEvent {
  /// Returns any data passed when initializing the event.
  ///
  external dynamic get detail;

  ///  Initializes a [CustomEvent] object. If the event has already
  /// being dispatched, this method does nothing.
  ///
  /// event.initCustomEvent(type, canBubble, cancelable, detail);
  ///
  @deprecated
  external Object initCustomEvent(String type,
      [bool? bubbles = false, bool? cancelable = false, dynamic detail]);
}

@anonymous
@JS()
@staticInterop
class CustomEventInit implements EventInit {
  external factory CustomEventInit({dynamic detail});
}

extension PropsCustomEventInit on CustomEventInit {
  external dynamic get detail;
  external set detail(dynamic newValue);
}

///
///   The interface is implemented by objects that can receive events
/// and may have listeners for them.
///   In other words, any target of events implements the three
/// methods associated with this interface.
///   [Element], and its children, as well as [Document] and
/// [Window], are the most common event targets,
///  but other objects can be event targets, too.
///   For example [XMLHttpRequest], [AudioNode], and [AudioContext]
/// are also event targets.
///
///  Many event targets (including elements, documents, and windows)
/// also support setting event handlers via [onevent] properties and
/// attributes.
@JS()
@staticInterop
class EventTarget {
  external factory EventTarget();
}

extension PropsEventTarget on EventTarget {
  ///  Registers an event handler of a specific event type on the
  /// [EventTarget].
  ///
  /// addEventListener(type, listener);
  /// addEventListener(type, listener, options);
  /// addEventListener(type, listener, useCapture);
  ///
  external Object addEventListener(String type, EventListener? callback,
      [dynamic options]);

  /// Removes an event listener from the [EventTarget].
  ///
  /// removeEventListener(type, listener);
  /// removeEventListener(type, listener, options);
  /// removeEventListener(type, listener, useCapture);
  ///
  ///
  ///  This example shows how to add a mouseover-based event listener that
  ///  removes a click-based event listener.
  ///
  /// const body = document.querySelector('body')
  /// const clickTarget = document.getElementById('click-target')
  /// const mouseOverTarget = document.getElementById('mouse-over-target')
  ///
  /// let toggle = false;
  /// function makeBackgroundYellow() {
  ///  if (toggle) {
  ///   body.style.backgroundColor = 'white';
  ///  } else {
  ///   body.style.backgroundColor = 'yellow';
  ///  }
  ///
  ///  toggle = !toggle;
  /// }
  ///
  /// clickTarget.addEventListener('click',
  ///  makeBackgroundYellow,
  ///  false
  /// );
  ///
  /// mouseOverTarget.addEventListener('mouseover', function () {
  ///  clickTarget.removeEventListener('click',
  ///   makeBackgroundYellow,
  ///   false
  ///  );
  /// });
  ///
  external Object removeEventListener(String type, EventListener? callback,
      [dynamic options]);

  /// Dispatches an event to this [EventTarget].
  ///
  /// dispatchEvent(event)
  ///
  /// See Creating and triggering events.
  external bool dispatchEvent(Event event);
}

///  The interface represents an object that can handle an event
/// dispatched by an [EventTarget] object.
///
///   Note: Due to the need for compatibility with legacy content,
/// accepts both a function and an object with a [handleEvent()]
/// property function. This is shown in the example below.
///
@JS()
@staticInterop
class EventListener {
  external factory EventListener();
}

extension PropsEventListener on EventListener {
  ///  A function that is called whenever an event of the specified
  /// type occurs.
  ///
  /// eventListener.handleEvent(event);
  ///
  external Object handleEvent(Event event);
}

@anonymous
@JS()
@staticInterop
class EventListenerOptions {
  external factory EventListenerOptions({bool capture = false});
}

extension PropsEventListenerOptions on EventListenerOptions {
  external bool get capture;
  external set capture(bool newValue);
}

@anonymous
@JS()
@staticInterop
class AddEventListenerOptions implements EventListenerOptions {
  external factory AddEventListenerOptions(
      {bool passive = false, bool once = false, AbortSignal signal});
}

extension PropsAddEventListenerOptions on AddEventListenerOptions {
  external bool get passive;
  external set passive(bool newValue);
  external bool get once;
  external set once(bool newValue);
  external AbortSignal get signal;
  external set signal(AbortSignal newValue);
}

///  The interface represents a controller object that allows you to
/// abort one or more Web requests as and when desired.
///  You can create a new object using the [AbortController()]
/// constructor. Communicating with a DOM request is done using an
/// [AbortSignal] object.
@experimental
@JS()
@staticInterop
class AbortController {
  external factory AbortController();
}

extension PropsAbortController on AbortController {
  ///  Returns an [AbortSignal] object instance, which can be used to
  /// communicate with, or to abort, a DOM request.
  ///
  external AbortSignal get signal;

  ///  Aborts a DOM request before it has completed. This is able to
  /// abort fetch requests, consumption of any response bodies, and
  /// streams.
  ///
  /// abort()
  /// abort(reason)
  ///
  external Object abort();
}

///  The interface represents a signal object that allows you to
/// communicate with a DOM request (such as a fetch request) and
/// abort it if required via an [AbortController] object.
@experimental
@JS()
@staticInterop
class AbortSignal implements EventTarget {
  external factory AbortSignal();
}

extension PropsAbortSignal on AbortSignal {
  external static AbortSignal abort();

  ///  A Boolean that indicates whether the request(s) the signal is
  /// communicating with is/are aborted ([true]) or not ([false]).
  ///
  external bool get aborted;
  external EventHandlerNonNull? get onabort;
  external set onabort(EventHandlerNonNull? newValue);
}

@JS()
@staticInterop
class NonElementParentNode {
  external factory NonElementParentNode();
}

extension PropsNonElementParentNode on NonElementParentNode {
  external Element? getElementById(String elementId);
}

@JS()
@staticInterop
class DocumentOrShadowRoot {
  external factory DocumentOrShadowRoot();
}

extension PropsDocumentOrShadowRoot on DocumentOrShadowRoot {
  external Iterable<Animation> getAnimations();
  external Element? get pointerLockElement;
  external Element? get fullscreenElement;
  external Iterable<CSSStyleSheet> get adoptedStyleSheets;
  external set adoptedStyleSheets(Iterable<CSSStyleSheet> newValue);
  external Element? get pictureInPictureElement;
  external Element? get activeElement;
  external StyleSheetList get styleSheets;
}

@JS()
@staticInterop
class ParentNode {
  external factory ParentNode();
}

extension PropsParentNode on ParentNode {
  external HTMLCollection get children;
  external Element? get firstElementChild;
  external Element? get lastElementChild;
  external int get childElementCount;
  external Object prepend([dynamic nodes]);
  external Object append([dynamic nodes]);
  external Object replaceChildren([dynamic nodes]);
  external Element? querySelector(String selectors);
  external NodeList querySelectorAll(String selectors);
}

@JS()
@staticInterop
class NonDocumentTypeChildNode {
  external factory NonDocumentTypeChildNode();
}

extension PropsNonDocumentTypeChildNode on NonDocumentTypeChildNode {
  external Element? get previousElementSibling;
  external Element? get nextElementSibling;
}

@JS()
@staticInterop
class ChildNode {
  external factory ChildNode();
}

extension PropsChildNode on ChildNode {
  external Object before([dynamic nodes]);
  external Object after([dynamic nodes]);
  external Object replaceWith([dynamic nodes]);
  external Object remove();
}

@JS()
@staticInterop
class Slottable {
  external factory Slottable();
}

extension PropsSlottable on Slottable {
  external HTMLSlotElement? get assignedSlot;
}

///   objects are collections of nodes, usually returned by
/// properties such as [Node.childNodes] and methods such as
/// [document.querySelectorAll()].
///
///   Note: Although is not an [Array], it is possible to iterate
/// over it with [forEach()]. It can also be converted to a real
/// [Array] using [Array.from()].
///   However, some older browsers have not implemented
/// [NodeList.forEach()] nor [Array.from()]. This can be circumvented
/// by using [Array.prototype.forEach()] — see this document's
/// Example.
///
@JS()
@staticInterop
class NodeList {
  external factory NodeList();
}

extension PropsNodeList on NodeList {
  ///  Returns an item in the list by its index, or [null] if the index
  /// is out-of-bounds.
  ///    An alternative to accessing [nodeList[i]] (which instead
  /// returns [undefined] when [i] is out-of-bounds). This is mostly
  /// useful for non-JavaScript DOM implementations.
  ///
  /// nodeItem = nodeList.item(index)
  ///
  ///   nodeList is a NodeList. This is usually obtained from
  ///   another DOM property or method, such as childNodes.
  ///
  ///  index is the index of the node to be fetched. The index is zero-based.
  ///
  ///   nodeItem is the indexth node in the nodeList
  ///   returned by the item method.
  ///
  ///
  /// var tables = document.getElementsByTagName("table");
  /// var firstTable = tables.item(1); // or tables[1] - returns the second table in the DOM
  ///
  external Node? item(int index);

  /// The number of nodes in the [NodeList].
  ///
  external int get length;
}

///  The interface represents a generic collection (array-like object
/// similar to [arguments]) of elements (in document order) and
/// offers methods and properties for selecting from the list.
///
///   Note: This interface is called for historical reasons (before
/// the modern DOM, collections implementing this interface could
/// only have HTML elements as their items).
///
///  An in the HTML DOM is live; it is automatically updated when the
/// underlying document is changed. For this reason it is a good idea
/// to make a copy (eg. using [Array.from]) to iterate over if
/// adding, moving, or removing nodes.
@JS()
@staticInterop
class HTMLCollection {
  external factory HTMLCollection();
}

extension PropsHTMLCollection on HTMLCollection {
  /// Returns the number of items in the collection.
  ///
  external int get length;

  ///  Returns the specific node at the given zero-based [index] into
  /// the list. Returns [null] if the [index] is out of range.
  ///    An alternative to accessing [collection[i]] (which instead
  /// returns [undefined] when [i] is out-of-bounds). This is mostly
  /// useful for non-JavaScript DOM implementations.
  ///
  /// var element = HTMLCollection.item(index)
  ///
  /// var c = document.images; // This is an HTMLCollection
  /// var img0 = c.item(0);   // You can use the item() method this way
  /// var img1 = c[1];     // But this notation is easier and more common
  ///
  external Element? item(int index);

  ///  Returns the specific node whose ID or, as a fallback, name
  /// matches the string specified by [name]. Matching by name is only
  /// done as a last resort, only in HTML, and only if the referenced
  /// element supports the [name] attribute. Returns [null] if no node
  /// exists by the given name.
  ///    An alternative to accessing [collection[name]] (which instead
  /// returns [undefined] when [name] does not exist). This is mostly
  /// useful for non-JavaScript DOM implementations.
  ///
  /// const item = collection.namedItem(key);
  ///
  external dynamic namedItem(String name);
}

///  The interface provides the ability to watch for changes being
/// made to the DOM tree. It is designed as a replacement for the
/// older Mutation Events feature, which was part of the DOM3 Events
/// specification.
@JS()
@staticInterop
class MutationObserver {
  external factory MutationObserver(MutationCallback callback);
}

extension PropsMutationObserver on MutationObserver {
  ///  Configures the [MutationObserver] to begin receiving
  /// notifications through its callback function when DOM changes
  /// matching the given options occur.
  ///
  /// mutationObserver.observe(target, options)
  ///
  external Object observe(Node target, [MutationObserverInit? options]);

  ///  Stops the [MutationObserver] instance from receiving further
  /// notifications until and unless [observe()] is called again.
  ///
  /// mutationObserver.disconnect()
  ///
  ///
  ///  This example creates an observer, then disconnects from it, leaving it available for
  ///  possible reuse.
  ///
  /// const targetNode = document.querySelector("#someElement");
  /// const observerOptions = {
  ///  childList: true,
  ///  attributes: true
  /// }
  ///
  /// const observer = new MutationObserver(callback);
  /// observer.observe(targetNode, observerOptions);
  ///
  /// /* some time later... */
  ///
  /// observer.disconnect();
  ///
  external Object disconnect();

  ///  Removes all pending notifications from the [MutationObserver]'s
  /// notification queue and returns them in a new [Array] of
  /// [MutationRecord] objects.
  ///
  /// const mutationRecords = mutationObserver.takeRecords()
  ///
  ///
  ///  In this example, we demonstrate how to handle any undelivered
  ///  MutationRecords by calling takeRecords() just before
  ///  disconnecting the observer.
  ///
  /// const targetNode = document.querySelector("#someElement");
  /// const observerOptions = {
  ///  childList: true,
  ///  attributes: true
  /// }
  ///
  /// const observer = new MutationObserver(callback);
  /// observer.observe(targetNode, observerOptions);
  ///
  /// /* ...later, when it's time to stop observing... */
  ///
  /// /* handle any still-pending mutations */
  ///
  /// let mutations = observer.takeRecords();
  ///
  /// observer.disconnect();
  ///
  /// if (mutations) {
  ///  callback(mutations);
  /// }
  ///  The code in lines 12–17 fetches any unprocessed mutation records, then invokes the
  ///  callback with the records so that they can be processed. This is done immediately prior
  ///  to calling disconnect() to stop observing
  ///  the DOM.
  ///
  external Iterable<MutationRecord> takeRecords();
}

@anonymous
@JS()
@staticInterop
class MutationObserverInit {
  external factory MutationObserverInit(
      {bool childList = false,
      bool attributes,
      bool characterData,
      bool subtree = false,
      bool attributeOldValue,
      bool characterDataOldValue,
      Iterable<String> attributeFilter});
}

extension PropsMutationObserverInit on MutationObserverInit {
  external bool get childList;
  external set childList(bool newValue);
  external bool get attributes;
  external set attributes(bool newValue);
  external bool get characterData;
  external set characterData(bool newValue);
  external bool get subtree;
  external set subtree(bool newValue);
  external bool get attributeOldValue;
  external set attributeOldValue(bool newValue);
  external bool get characterDataOldValue;
  external set characterDataOldValue(bool newValue);
  external Iterable<String> get attributeFilter;
  external set attributeFilter(Iterable<String> newValue);
}

///  A represents an individual DOM mutation. It is the object that
/// is inside the array passed to [MutationObserver]'s callback.
@JS()
@staticInterop
class MutationRecord {
  external factory MutationRecord();
}

extension PropsMutationRecord on MutationRecord {
  external String get type;
  external Node get target;
  external NodeList get addedNodes;
  external NodeList get removedNodes;
  external Node? get previousSibling;
  external Node? get nextSibling;
  external String? get attributeName;
  external String? get attributeNamespace;
  external String? get oldValue;
}

///
///  The DOM interface is an abstract base
///   class upon which many other DOM API objects are based, thus
/// letting those object types
///   to be used similarly and often interchangeably. As an abstract
/// class, there is
///  no such thing as a plain object. All objects that implement
///    functionality are based on one of its subclasses. Most notable
/// are
///  [Document], [Element], and [DocumentFragment].
///   In addition, every kind of DOM node is represented by an
/// interface based on
///  . These include [Attr], [CharacterData]
///  (which [Text], [Comment], [CDATASection] and
///  [ProcessingInstruction] are all based on), and [DocumentType].
///   In some cases, a particular feature of the base interface may
/// not
///   apply to one of its child interfaces; in that case, the
/// inheriting node may
///   return [null] or throw an exception, depending on
/// circumstances. For example,
///   attempting to add children to a node type that cannot have
/// children will throw an
///  exception.
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
@JS()
@staticInterop
class Node implements EventTarget {
  external static int get ELEMENT_NODE;
  external static int get ATTRIBUTE_NODE;
  external static int get TEXT_NODE;
  external static int get CDATA_SECTION_NODE;
  external static int get ENTITY_REFERENCE_NODE;
  external static int get ENTITY_NODE;
  external static int get PROCESSING_INSTRUCTION_NODE;
  external static int get COMMENT_NODE;
  external static int get DOCUMENT_NODE;
  external static int get DOCUMENT_TYPE_NODE;
  external static int get DOCUMENT_FRAGMENT_NODE;
  external static int get NOTATION_NODE;
  external static int get DOCUMENT_POSITION_DISCONNECTED;
  external static int get DOCUMENT_POSITION_PRECEDING;
  external static int get DOCUMENT_POSITION_FOLLOWING;
  external static int get DOCUMENT_POSITION_CONTAINS;
  external static int get DOCUMENT_POSITION_CONTAINED_BY;
  external static int get DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
  external factory Node();
}

extension PropsNode on Node {
  ///
  ///     Returns an [unsigned short] representing the type of the
  /// node. Possible
  ///    values are:
  ///
  ///
  ///
  ///
  ///      Name
  ///      Value
  ///
  ///
  ///
  ///
  ///      [ELEMENT_NODE]
  ///      [1]
  ///
  ///
  ///      [ATTRIBUTE_NODE]
  ///      [2]
  ///
  ///
  ///      [TEXT_NODE]
  ///      [3]
  ///
  ///
  ///      [CDATA_SECTION_NODE]
  ///      [4]
  ///
  ///
  ///      [PROCESSING_INSTRUCTION_NODE]
  ///      [7]
  ///
  ///
  ///      [COMMENT_NODE]
  ///      [8]
  ///
  ///
  ///      [DOCUMENT_NODE]
  ///      [9]
  ///
  ///
  ///      [DOCUMENT_TYPE_NODE]
  ///      [10]
  ///
  ///
  ///      [DOCUMENT_FRAGMENT_NODE]
  ///      [11]
  ///
  ///
  ///
  ///
  external int get nodeType;

  ///
  ///    Returns a [String] containing the name of the [Node]. The
  ///    structure of the name will differ with the node type. E.g. An
  ///     [HTMLElement] will contain the name of the corresponding tag,
  /// like
  ///    ['audio'] for an [HTMLAudioElement], a [Text]
  ///     node will have the ['#text'] string, or a [Document] node
  /// will
  ///    have the ['#document'] string.
  ///
  ///
  external String get nodeName;

  ///
  ///    Returns a [String] representing the base URL of the document
  ///    containing the [Node].
  ///
  ///
  external String get baseURI;

  ///
  ///     A boolean indicating whether or not the Node is connected
  /// (directly or indirectly)
  ///     to the context object, e.g. the [Document] object in the case
  /// of the
  ///    normal DOM, or the [ShadowRoot] in the case of a shadow DOM.
  ///
  ///
  external bool get isConnected;

  ///
  ///     Returns the [Document] that this node belongs to. If the node
  /// is itself
  ///    a document, returns [null].
  ///
  ///
  external Document? get ownerDocument;

  ///
  ///     Returns the context object's root which optionally includes
  /// the shadow root if it is
  ///    available.
  ///
  ///
  /// getRootNode();
  /// getRootNode(options);
  ///
  external Node getRootNode([GetRootNodeOptions? options]);

  ///
  ///     Returns a [Node] that is the parent of this node. If there is
  /// no such
  ///     node, like if this node is the top of the tree or if doesn't
  /// participate in a tree,
  ///    this property returns [null].
  ///
  ///
  external Node? get parentNode;

  ///
  ///     Returns an [Element] that is the parent of this node. If the
  /// node has
  ///     no parent, or if that parent is not an [Element], this
  /// property returns
  ///    [null].
  ///
  ///
  external Element? get parentElement;

  ///
  ///     Returns a boolean value indicating whether or not the element
  /// has any child
  ///    nodes.
  ///
  ///
  /// hasChildNodes();
  ///
  /// let foo = document.getElementById('foo');
  ///
  /// if (foo.hasChildNodes()) {
  ///  // Do something with 'foo.childNodes'
  /// }
  ///
  external bool hasChildNodes();

  ///
  ///     Returns a live [NodeList] containing all the children of this
  /// node
  ///     (including elements, text and comments). [NodeList] being
  /// live means that
  ///     if the children of the [Node] change, the [NodeList] object
  /// is
  ///    automatically updated.
  ///
  ///
  external NodeList get childNodes;

  ///
  ///     Returns a [Node] representing the first direct child node of
  /// the node,
  ///    or [null] if the node has no child.
  ///
  ///
  external Node? get firstChild;

  ///
  ///     Returns a [Node] representing the last direct child node of
  /// the node,
  ///    or [null] if the node has no child.
  ///
  ///
  external Node? get lastChild;

  ///
  ///     Returns a [Node] representing the previous node in the tree,
  /// or
  ///    [null] if there isn't such node.
  ///
  ///
  external Node? get previousSibling;

  ///
  ///    Returns a [Node] representing the next node in the tree, or
  ///    [null] if there isn't such node.
  ///
  ///
  external Node? get nextSibling;

  /// Returns / Sets the value of the current node.
  ///
  external String? get nodeValue;
  external set nodeValue(String? newValue);

  ///  Returns / Sets the textual content of an element and all its
  /// descendants.
  ///
  external String? get textContent;
  external set textContent(String? newValue);

  ///  Clean up all the text nodes under this element (merge adjacent,
  /// remove empty).
  ///
  /// normalize();
  ///
  /// <output id="result"></output>
  ///
  /// let wrapper = document.createElement("div");
  ///
  /// wrapper.appendChild( document.createTextNode("Part 1 ") );
  /// wrapper.appendChild( document.createTextNode("Part 2 ") );
  ///
  /// let node = wrapper.firstChild;
  /// let result = "Before normalization:<br/>";
  /// while (node) {
  ///  result += " " + node.nodeName + ": " + node.nodeValue + "<br/>";
  ///  node = node.nextSibling;
  /// }
  ///
  /// wrapper.normalize();
  ///
  /// node = wrapper.firstChild;
  /// result += "<br/><br/>After normalization:<br/>";
  /// while (node) {
  ///  result += " " + node.nodeName + ": " + node.nodeValue + "<br/>";
  ///  node = node.nextSibling;
  /// }
  ///
  /// const output = document.getElementById("result");
  /// output.innerHTML = result;
  ///
  external Object normalize();

  ///
  ///     Clone a [Node], and optionally, all of its contents. By
  /// default, it
  ///    clones the content of the node.
  ///
  ///
  /// cloneNode();
  /// cloneNode(deep);
  ///
  /// let p = document.getElementById("para1")
  /// let p_prime = p.cloneNode(true)
  ///
  external Node cloneNode([bool? deep = false]);

  ///
  ///     Returns a boolean value which indicates whether or not two
  /// nodes are of the
  ///    same type and all their defining data points match.
  ///
  ///
  /// isEqualNode(otherNode);
  ///
  ///
  ///  In this example, we create three <div> blocks. The first and third
  ///  have the same contents and attributes, while the second is different. Then we run some
  ///  JavaScript to compare the nodes using isEqualNode() and output the results.
  ///
  /// <div>This is the first element.</div>
  /// <div>This is the second element.</div>
  /// <div>This is the first element.</div>
  ///
  /// <p id="output"></p>
  ///
  /// ```
  ///
  /// #output {
  ///  width: 440px;
  ///  border: 2px solid black;
  ///  border-radius: 5px;
  ///  padding: 10px;
  ///  margin-top: 20px;
  ///  display: block;
  /// }
  ///
  /// ```
  ///
  /// let output = document.getElementById("output");
  /// let divList = document.getElementsByTagName("div");
  ///
  /// output.innerHTML += "div 0 equals div 0: " + divList[0].isEqualNode(divList[0]) + "<br/>";
  /// output.innerHTML += "div 0 equals div 1: " + divList[0].isEqualNode(divList[1]) + "<br/>";
  /// output.innerHTML += "div 0 equals div 2: " + divList[0].isEqualNode(divList[2]) + "<br/>";
  ///
  /// ```
  ///
  ///
  external bool isEqualNode(Node? otherNode);

  ///
  ///     Returns a boolean value indicating whether or not the two
  /// nodes are
  ///    the same (that is, they reference the same object).
  ///
  ///
  /// isSameNode(otherNode);
  ///
  ///
  ///  In this example, we create three <div> blocks. The first and third
  ///  have the same contents and attributes, while the second is different. Then we run some
  ///  JavaScript to compare the nodes using isSameNode() and output the results.
  ///
  /// <div>This is the first element.</div>
  /// <div>This is the second element.</div>
  /// <div>This is the first element.</div>
  ///
  /// <p id="output"></p>
  ///
  /// ```
  ///
  /// #output {
  ///  width: 440px;
  ///  border: 2px solid black;
  ///  border-radius: 5px;
  ///  padding: 10px;
  ///  margin-top: 20px;
  ///  display: block;
  /// }
  ///
  /// ```
  ///
  /// let output = document.getElementById("output");
  /// let divList = document.getElementsByTagName("div");
  ///
  /// output.innerHTML += "div 0 same as div 0: " + divList[0].isSameNode(divList[0]) + "<br/>";
  /// output.innerHTML += "div 0 same as div 1: " + divList[0].isSameNode(divList[1]) + "<br/>";
  /// output.innerHTML += "div 0 same as div 2: " + divList[0].isSameNode(divList[2]) + "<br/>";
  ///
  /// ```
  ///
  ///
  external bool isSameNode(Node? otherNode);

  ///
  ///     Compares the position of the current node against another
  /// node in any other
  ///    document.
  ///
  ///
  /// compareDocumentPosition(otherNode);
  ///
  /// const head = document.head;
  /// const body = document.body;
  ///
  /// if (head.compareDocumentPosition(body) & Node.DOCUMENT_POSITION_FOLLOWING) {
  ///  console.log('Well-formed document');
  /// } else {
  ///  console.error('<head> is not before <body>');
  /// }
  ///
  ///   Note: Because the result returned by compareDocumentPosition() is a bitmask,
  ///   the bitwise AND operator
  ///   must be used for meaningful results.
  ///
  ///
  external int compareDocumentPosition(Node other);

  ///
  ///     Returns [true] or [false] value indicating whether or not a
  /// node is a
  ///    descendant of the calling node.
  ///
  ///
  /// contains(otherNode);
  ///
  ///
  ///  This function checks to see if an element is in the page's body. As
  ///  contains is inclusive and determining if the body contains itself isn't the
  ///  intention of isInPage this case explicitly returns false.
  ///
  /// function isInPage(node) {
  ///  return (node === document.body) ? false : document.body.contains(node);
  /// }
  ///
  external bool contains(Node? other);

  ///
  ///     Returns a [DOMString] containing the prefix for a given
  /// namespace URI,
  ///     if present, and [null] if not. When multiple prefixes are
  /// possible, the
  ///    result is implementation-dependent.
  ///
  ///
  /// lookupPrefix(namespace);
  ///
  /// Prefix for <code>http://www.w3.org/2000/svg</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/XML/1998/namespace</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/TR/html4/</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>https://www.w3.org/1999/xlink</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/2000/svg</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>https://www.w3.org/1999/xlink</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/XML/1998/namespace</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// <svg xmlns:t="http://www.w3.org/2000/svg" height="1"></svg>
  /// <button>Click to see the results</button>
  ///
  /// const button = document.getElementsByTagName('button')[0];
  /// button.addEventListener("click", function () {
  ///  const aHtmlElt = document.getElementsByTagName('output')[0];
  ///  const aSvgElt = document.getElementsByTagName('svg')[0];
  ///
  ///  const result = document.getElementsByTagName('output');
  ///  result[0].value = aHtmlElt.lookupPrefix("http://www.w3.org/2000/svg"); // true
  ///  result[1].value = aHtmlElt.lookupPrefix("http://www.w3.org/XML/1998/namespace"); // false
  ///  result[2].value = aHtmlElt.lookupPrefix("http://www.w3.org/TR/html4/"); // true
  ///  result[3].value = aHtmlElt.lookupPrefix("https://www.w3.org/1999/xlink"); // false
  ///  result[4].value = aSvgElt.lookupPrefix("http://www.w3.org/2000/svg"); // true
  ///  result[5].value = aSvgElt.lookupPrefix("https://www.w3.org/1999/xlink"); // true
  ///  result[6].value = aSvgElt.lookupPrefix("http://www.w3.org/XML/1998/namespace"); // false
  /// });
  ///
  external String? lookupPrefix(String? namespace);

  ///
  ///     Accepts a prefix and returns the namespace URI associated
  /// with it on the given node
  ///    if found (and [null] if not). Supplying [null] for the prefix
  ///    will return the default namespace.
  ///
  ///
  /// lookupNamespaceURI(prefix);
  ///
  /// Namespace URL for <code>xlink</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>xml</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>html</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>``</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>svg</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>xlink</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>xml</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// <svg xmlns:svg="http://www.w3.org/2000/svg" height="1"></svg>
  /// <button>Click to see the results</button>
  ///
  /// const button = document.getElementsByTagName('button')[0];
  /// button.addEventListener("click", function () {
  ///  const aHtmlElt = document.getElementsByTagName('output')[0];
  ///  const aSvgElt = document.getElementsByTagName('svg')[0];
  ///
  ///  const result = document.getElementsByTagName('output');
  ///  result[0].value = aHtmlElt.lookupNamespaceURI("xlink");
  ///  result[1].value = aHtmlElt.lookupNamespaceURI("xml");
  ///  result[2].value = aHtmlElt.lookupNamespaceURI("html");
  ///  result[3].value = aHtmlElt.lookupNamespaceURI("");
  ///  result[4].value = aSvgElt.lookupNamespaceURI("svg");
  ///  result[5].value = aSvgElt.lookupNamespaceURI("xlink");
  ///  result[6].value = aSvgElt.lookupNamespaceURI("xml");
  /// });
  ///
  external String? lookupNamespaceURI(String? prefix);

  ///
  ///     Accepts a namespace URI as an argument and returns a boolean
  /// value with a
  ///     value of [true] if the namespace is the default namespace on
  /// the given node
  ///    or [false] if not.
  ///
  ///
  /// isDefaultNamespace(namespaceURI);
  ///
  /// Is "" the default namespace for &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Is "http://www.w3.org/2000/svg" the default namespace for &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Is "" the default namespace for &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Is "http://www.w3.org/2000/svg" the default namespace for &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// <svg xmlns="http://www.w3.org/2000/svg" height="1"></svg>
  /// <button>Click to see the results</button>
  ///
  /// const button = document.getElementsByTagName('button')[0];
  /// button.addEventListener("click", function () {
  ///  const aHtmlElt = document.getElementsByTagName('output')[0];
  ///  const aSvgElt = document.getElementsByTagName('svg')[0];
  ///
  ///  const result = document.getElementsByTagName('output');
  ///  result[0].value = aHtmlElt.isDefaultNamespace(""); // true
  ///  result[1].value = aHtmlElt.isDefaultNamespace("http://www.w3.org/2000/svg"); // false
  ///  result[2].value = aSvgElt.isDefaultNamespace(""); // true
  ///  result[3].value = aSvgElt.isDefaultNamespace("http://www.w3.org/2000/svg"); // false
  /// });
  ///
  external bool isDefaultNamespace(String? namespace);

  ///
  ///     Inserts a [Node] before the reference node as a child of a
  /// specified
  ///    parent node.
  ///
  ///
  /// insertBefore(newNode, referenceNode);
  ///
  external Node insertBefore(Node node, Node? child);

  ///
  ///    Adds the specified [childNode] argument as the last child to
  ///    the current node.
  ///     If the argument referenced an existing node on the DOM tree,
  /// the node will be detached
  ///    from its current position and attached at the new position.
  ///
  ///
  /// appendChild(aChild);
  ///
  /// // Create a new paragraph element, and append it to the end of the document body
  /// let p = document.createElement("p");
  /// document.body.appendChild(p);
  ///
  Node appendChild(Node node) => js_util.callMethod(this, 'appendChild', [node]);

  ///
  ///     Replaces one child [Node] of the current one with the second
  /// one given
  ///    in parameter.
  ///
  ///
  /// replaceChild(newChild, oldChild);
  ///
  /// // Given:
  /// // <div>
  /// // <span id="childSpan">foo bar</span>
  /// // </div>
  ///
  /// // Create an empty element node
  /// // without an ID, any attributes, or any content
  /// const sp1 = document.createElement("span");
  ///
  /// // Give it an id attribute called 'newSpan'
  /// sp1.id = "newSpan";
  ///
  /// // Create some content for the new element.
  /// const sp1_content = document.createTextNode("new replacement span element.");
  ///
  /// // Apply that content to the new element
  /// sp1.appendChild(sp1_content);
  ///
  /// // Build a reference to the existing node to be replaced
  /// const sp2 = document.getElementById("childSpan");
  /// const parentDiv = sp2.parentNode;
  ///
  /// // Replace existing node sp2 with the new span element sp1
  /// parentDiv.replaceChild(sp1, sp2);
  ///
  /// // Result:
  /// // <div>
  /// //  <span id="newSpan">new replacement span element.</span>
  /// // </div>
  ///
  external Node replaceChild(Node node, Node child);

  ///
  ///     Removes a child node from the current element, which must be
  /// a child of the current
  ///    node.
  ///
  ///
  /// removeChild(child);
  ///
  external Node removeChild(Node child);
}

@anonymous
@JS()
@staticInterop
class GetRootNodeOptions {
  external factory GetRootNodeOptions({bool composed = false});
}

extension PropsGetRootNodeOptions on GetRootNodeOptions {
  external bool get composed;
  external set composed(bool newValue);
}

///  The interface represents any web page loaded in the browser and
/// serves as an entry point into the web page's content, which is
/// the DOM tree.
///  The DOM tree includes elements such as [<body>] and [<table>],
/// among many others. It provides functionality globally to the
/// document, like how to obtain the page's URL and create new
/// elements in the document.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Document
///
///
///  The interface describes the common properties and methods for
/// any kind of document. Depending on the document's type (e.g.
/// HTML, XML, SVG, …), a larger API is available: HTML documents,
/// served with the ["text/html"] content type, also implement the
/// [HTMLDocument] interface, whereas XML and SVG documents implement
/// the [XMLDocument] interface.
@JS()
@staticInterop
class Document
    implements
        Node,
        GeometryUtils,
        FontFaceSource,
        NonElementParentNode,
        DocumentOrShadowRoot,
        ParentNode,
        XPathEvaluatorBase,
        GlobalEventHandlers,
        DocumentAndElementEventHandlers {
  external factory Document();
}

extension PropsDocument on Document {
  ///  Returns the DOM implementation associated with the current
  /// document.
  ///
  external DOMImplementation get implementation;
  external String get URL;

  /// Returns the document location as a string.
  ///
  external String get documentURI;

  ///  Indicates whether the document is rendered in quirks or strict
  /// mode.
  ///
  @experimental
  external String get compatMode;

  /// Returns the character set being used by the document.
  ///
  external String get characterSet;
  external String get charset;
  external String get inputEncoding;

  ///  Returns the Content-Type from the MIME Header of the current
  /// document.
  ///
  @experimental
  external String get contentType;

  ///  Returns the Document Type Definition (DTD) of the current
  /// document.
  ///
  external DocumentType? get doctype;

  ///  Returns the [Element] that is a direct child of the document.
  /// For HTML documents, this is normally the [HTMLHtmlElement] object
  /// representing the document's [<html>] element.
  ///
  external Element? get documentElement;

  /// Returns a list of elements with the given tag name.
  ///
  /// var elements = document.getElementsByTagName(name);
  ///
  ///   elements is a live HTMLCollection (but see the note below)
  ///   of found elements in the order they appear in the tree.
  ///
  ///
  ///   name is a string representing the name of the elements. The special
  ///   string "*" represents all elements.
  ///
  ///
  ///   Note: The
  /// latest W3C specification says elements is an
  ///   HTMLCollection; however, this method returns a NodeList in
  ///   WebKit browsers. See bug 14869 for details.
  ///
  ///
  ///
  ///  In the following example, getElementsByTagName() starts from a particular
  ///  parent element and searches top-down recursively through the DOM from that parent
  ///  element, building a collection of all descendant elements which match the tag
  ///  name parameter. This demonstrates both
  ///  document.getElementsByTagName() and the functionally identical
  ///  Element.getElementsByTagName(), which starts the search at a specific
  ///  element within the DOM tree.
  ///  Clicking the buttons uses getElementsByTagName() to count the descendant
  ///  paragraph elements of a particular parent (either the document itself or one of two
  ///  nested <div> elements).
  ///
  /// <!DOCTYPE html>
  /// <html lang="en">
  /// <head>
  ///  <meta charset="UTF-8" />
  ///  <title>getElementsByTagName example</title>
  ///  <script>
  ///   function getAllParaElems() {
  ///    var allParas = document.getElementsByTagName('p');
  ///    var num = allParas.length;
  ///    alert('There are ' + num + ' paragraph in this document');
  ///   }
  ///
  ///   function div1ParaElems() {
  ///    var div1 = document.getElementById('div1');
  ///    var div1Paras = div1.getElementsByTagName('p');
  ///    var num = div1Paras.length;
  ///    alert('There are ' + num + ' paragraph in #div1');
  ///   }
  ///
  ///   function div2ParaElems() {
  ///    var div2 = document.getElementById('div2');
  ///    var div2Paras = div2.getElementsByTagName('p');
  ///    var num = div2Paras.length;
  ///    alert('There are ' + num + ' paragraph in #div2');
  ///   }
  ///  </script>
  /// </head>
  /// <body style="border: solid green 3px">
  ///  <p>Some outer text</p>
  ///  <p>Some outer text</p>
  ///
  ///  <div id="div1" style="border: solid blue 3px">
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///
  ///   <div id="div2" style="border: solid red 3px">
  ///    <p>Some div2 text</p>
  ///    <p>Some div2 text</p>
  ///   </div>
  ///  </div>
  ///
  ///  <p>Some outer text</p>
  ///  <p>Some outer text</p>
  ///
  ///  <button onclick="getAllParaElems();">
  ///   show all p elements in document</button><br />
  ///
  ///  <button onclick="div1ParaElems();">
  ///   show all p elements in div1 element</button><br />
  ///
  ///  <button onclick="div2ParaElems();">
  ///   show all p elements in div2 element</button>
  ///
  /// </body>
  /// </html>
  ///
  external HTMLCollection getElementsByTagName(String qualifiedName);

  ///  Returns a list of elements with the given tag name and
  /// namespace.
  ///
  /// elements = document.getElementsByTagNameNS(namespace, name)
  ///
  ///   elements is a live NodeList (but see the note below) of
  ///   found elements in the order they appear in the tree.
  ///
  ///
  ///   namespace is the namespace URI of elements to look for (see
  ///   element.namespaceURI).
  ///
  ///
  ///   name is either the local name of elements to look for or the special
  ///   value *, which matches all elements (see element.localName).
  ///
  ///
  ///   Note: While the W3C specification says elements is a NodeList, this method returns a HTMLCollection both in Gecko and Internet Explorer.
  ///   Opera returns a NodeList, but with a namedItem method implemented, which makes it similar to a HTMLCollection. As of January 2012, only in WebKit browsers is the returned value a pure NodeList.
  ///   See bug 14869 for details.
  ///
  ///
  ///   Note: Currently parameters in this method are case-sensitive, but they were case-insensitive in Firefox 3.5 and before.
  ///   See the developer release note for Firefox 3.6 and a note in Browser compatibility section in Element.getElementsByTagNameNS for details.
  ///
  ///
  ///
  ///  In the following example getElementsByTagNameNS starts from a particular
  ///  parent element, and searches topdown recursively through the DOM from that parent
  ///  element, looking for child elements matching the tag name parameter.
  ///  Note that when the node on which getElementsByTagName is invoked is not
  ///  the document node, in fact the
  ///  element.getElementsByTagNameNS method is used.
  ///  To use the following example, just copy/paste it into a new file saved with the .xhtml
  ///  extension.
  ///
  /// <html xmlns="http://www.w3.org/1999/xhtml">
  ///
  /// <head>
  /// <title>getElementsByTagNameNS example</title>
  ///
  /// <script type="text/javascript">
  ///
  /// function getAllParaElems()
  /// {
  ///  var allParas = document.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "p");
  ///
  ///  var num = allParas.length;
  ///
  ///  alert("There are " + num + " &lt;p&gt; elements in this document");
  /// }
  ///
  /// function div1ParaElems()
  /// {
  ///  var div1 = document.getElementById("div1")
  ///  var div1Paras = div1.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "p");
  ///
  ///  var num = div1Paras.length;
  ///
  ///  alert("There are " + num + " &lt;p&gt; elements in div1 element");
  /// }
  ///
  /// function div2ParaElems()
  /// {
  ///  var div2 = document.getElementById("div2")
  ///  var div2Paras = div2.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "p");
  ///
  ///  var num = div2Paras.length;
  ///
  ///  alert("There are " + num + " &lt;p&gt; elements in div2 element");
  /// }
  ///
  /// </script>
  /// </head>
  ///
  /// <body style="border: solid green 3px">
  /// <p>Some outer text</p>
  /// <p>Some outer text</p>
  ///
  ///  <div id="div1" style="border: solid blue 3px">
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///
  ///   <div id="div2" style="border: solid red 3px">
  ///   <p>Some div2 text</p>
  ///   <p>Some div2 text</p>
  ///   </div>
  ///  </div>
  ///
  /// <p>Some outer text</p>
  /// <p>Some outer text</p>
  ///
  /// <button onclick="getAllParaElems();">
  ///  show all p elements in document</button><br />
  ///
  /// <button onclick="div1ParaElems();">
  ///  show all p elements in div1 element</button><br />
  ///
  /// <button onclick="div2ParaElems();">
  ///  show all p elements in div2 element</button>
  ///
  /// </body>
  /// </html>
  ///
  external HTMLCollection getElementsByTagNameNS(
      String? namespace, String localName);

  /// Returns a list of elements with the given class name.
  ///
  /// var elements = document.getElementsByClassName(names); // or:
  /// var elements = rootElement.getElementsByClassName(names);
  ///  elements is a live HTMLCollection of found elements.
  ///
  ///   names is a string representing the class name(s) to match; multiple class
  ///   names are separated by whitespace
  ///
  ///
  ///   getElementsByClassName can be
  ///   called on any element, not only on the document. The element on which
  ///   it is called will be used as the root of the search.
  ///
  ///
  external HTMLCollection getElementsByClassName(String classNames);

  /// Creates a new element with the given tag name.
  ///
  /// let element = document.createElement(tagName[, options]);
  ///
  Element createElement(String localName, [dynamic options]) =>
      js_util.callMethod(this, 'createElement', [localName, options]);

  /// Creates a new element with the given tag name and namespace URI.
  ///
  /// var element = document.createElementNS(namespaceURI, qualifiedName[, options]);
  ///
  ///
  ///  This creates a new <div> element in the XHTML namespace and
  ///  appends it to the vbox element. Although this is not an extremely useful XUL document, it does demonstrate the use of
  ///  elements from two different namespaces within a single document:
  ///
  /// <?xml version="1.0"?>
  /// <page xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
  ///    xmlns:html="http://www.w3.org/1999/xhtml"
  ///    title="||Working with elements||"
  ///    onload="init()">
  ///
  /// <script type="application/javascript"><![CDATA[
  ///  let container;
  ///  let newdiv;
  ///  let txtnode;
  ///
  ///  function init(){
  ///   container = document.getElementById("ContainerBox");
  ///   newdiv = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
  ///   txtnode = document.createTextNode("This is text that was constructed dynamically with createElementNS and createTextNode then inserted into the document using appendChild.");
  ///   newdiv.appendChild(txtnode);
  ///   container.appendChild(newdiv);
  ///  }
  ///
  /// ]]></script>
  ///
  ///  <vbox id="ContainerBox" flex="1">
  ///  <html:div>
  ///   The script on this page will add dynamic content below:
  ///  </html:div>
  ///  </vbox>
  ///
  /// </page>
  ///
  ///   Note: The example given above uses inline script which is not recommended in XHTML
  ///   documents. This particular example is actually an XUL document with embedded XHTML,
  ///   however, the recommendation still applies.
  ///
  ///
  external Element createElementNS(String? namespace, String qualifiedName,
      [dynamic options]);

  /// Creates a new document fragment.
  ///
  /// var fragment = document.createDocumentFragment();
  ///
  ///
  ///  This example creates a list of major web browsers in a DocumentFragment,
  ///  then adds the new DOM subtree to the document to be displayed.
  ///
  /// <ul id="ul">
  /// </ul>
  ///
  /// ```
  ///
  /// var element = document.getElementById('ul'); // assuming ul exists
  /// var fragment = document.createDocumentFragment();
  /// var browsers = ['Firefox', 'Chrome', 'Opera',
  ///   'Safari', 'Internet Explorer'];
  ///
  /// browsers.forEach(function(browser) {
  ///   var li = document.createElement('li');
  ///   li.textContent = browser;
  ///   fragment.appendChild(li);
  /// });
  ///
  /// element.appendChild(fragment);
  ///
  /// ```
  ///
  external DocumentFragment createDocumentFragment();

  /// Creates a text node.
  ///
  /// var text = document.createTextNode(data);
  ///  text is a Text node.
  ///
  ///   data is a string
  ///   containing the data to be put in the text node.
  ///
  ///
  /// <!DOCTYPE html>
  /// <html lang="en">
  /// <head>
  /// <title>createTextNode example</title>
  /// <script>
  /// function addTextNode(text) {
  ///  var newtext = document.createTextNode(text),
  ///    p1 = document.getElementById("p1");
  ///
  ///  p1.appendChild(newtext);
  /// }
  /// </script>
  /// </head>
  ///
  /// <body>
  ///  <button onclick="addTextNode('YES! ');">YES!</button>
  ///  <button onclick="addTextNode('NO! ');">NO!</button>
  ///  <button onclick="addTextNode('WE CAN! ');">WE CAN!</button>
  ///
  ///  <hr />
  ///
  ///  <p id="p1">First line of paragraph.</p>
  /// </body>
  /// </html>
  ///
  external Text createTextNode(String data);

  /// Creates a new CDATA node and returns it.
  ///
  /// var CDATASectionNode = document.createCDATASection(data);
  ///  CDATASectionNode is a CDATA
  /// Section node.
  ///  data is a string containing the data to be added to the CDATA Section.
  ///
  /// var docu = new DOMParser().parseFromString('<xml></xml>', 'application/xml')
  ///
  /// var cdata = docu.createCDATASection('Some <CDATA> data & then some');
  ///
  /// docu.getElementsByTagName('xml')[0].appendChild(cdata);
  ///
  /// alert(new XMLSerializer().serializeToString(docu));
  /// // Displays: <xml><![CDATA[Some <CDATA> data & then some]]></xml>
  ///
  external CDATASection createCDATASection(String data);

  /// Creates a new comment node and returns it.
  ///
  /// CommentNode = document.createComment(data);
  ///
  /// var docu = new DOMParser().parseFromString('<xml></xml>', 'application/xml');
  /// var comment = docu.createComment('This is a not-so-secret comment in your document');
  ///
  /// docu.getElementsByTagName('xml')[0].appendChild(comment);
  ///
  /// alert(new XMLSerializer().serializeToString(docu));
  /// // Displays: <xml><!--This is a not-so-secret comment in your document--></xml>
  ///
  external Comment createComment(String data);

  /// Creates a new [ProcessingInstruction] object.
  ///
  /// piNode = document.createProcessingInstruction(target, data)
  ///
  /// var doc = new DOMParser().parseFromString('<foo />', 'application/xml');
  /// var pi = doc.createProcessingInstruction('xml-stylesheet', 'href="mycss.css" type="text/css"');
  ///
  /// doc.insertBefore(pi, doc.firstChild);
  ///
  /// console.log(new XMLSerializer().serializeToString(doc));
  /// // Displays: <?xml-stylesheet href="mycss.css" type="text/css"?><foo/>
  ///
  external ProcessingInstruction createProcessingInstruction(
      String target, String data);

  /// Returns a clone of a node from an external document.
  ///
  /// importNode(externalNode)
  /// importNode(externalNode, deep)
  ///
  /// const iframe = document.querySelector("iframe");
  /// const oldNode = iframe.contentWindow.document.getElementById("myNode");
  /// const newNode = document.importNode(oldNode, true);
  /// document.getElementById("container").appendChild(newNode);
  ///
  external Node importNode(Node node, [bool? deep = false]);

  /// Adopt node from an external document.
  ///
  /// const importedNode = document.adoptNode(externalNode);
  ///
  /// const iframe = document.querySelector('iframe');
  /// const iframeImages = iframe.contentDocument.querySelectorAll('img');
  /// const newParent = document.getElementById('images');
  ///
  /// iframeImages.forEach(function(imgEl) {
  ///  newParent.appendChild(document.adoptNode(imgEl));
  /// });
  ///
  external Node adoptNode(Node node);

  /// Creates a new [Attr] object and returns it.
  ///
  /// attribute = document.createAttribute(name)
  ///
  /// var node = document.getElementById("div1");
  /// var a = document.createAttribute("my_attrib");
  /// a.value = "newVal";
  /// node.setAttributeNode(a);
  /// console.log(node.getAttribute("my_attrib")); // "newVal"
  ///
  external Attr createAttribute(String localName);

  ///  Creates a new attribute node in a given namespace and returns
  /// it.
  ///
  external Attr createAttributeNS(String? namespace, String qualifiedName);

  /// Creates an event object.
  ///
  /// var event = document.createEvent(type);
  ///  event is the created Event object.
  ///
  ///   type is a string that represents the type of event to be
  ///   created. Possible event types include "UIEvents",
  ///   "MouseEvents", "MutationEvents", and
  ///   "HTMLEvents". See Notes section for details.
  ///
  ///
  /// // Create the event.
  /// var event = document.createEvent('Event');
  ///
  /// // Define that the event name is 'build'.
  /// event.initEvent('build', true, true);
  ///
  /// // Listen for the event.
  /// elem.addEventListener('build', function (e) {
  ///  // e.target matches elem
  /// }, false);
  ///
  /// // Target can be any Element or other EventTarget.
  /// elem.dispatchEvent(event);
  ///
  external Event createEvent(String mInterface);

  /// Creates a [Range] object.
  ///
  /// range = document.createRange();
  ///
  /// range is the created Range object.
  /// let range = document.createRange();
  ///
  /// range.setStart(startNode, startOffset);
  /// range.setEnd(endNode, endOffset);
  ///
  external Range createRange();

  /// Creates a [NodeIterator] object.
  ///
  /// const nodeIterator = document.createNodeIterator(root[, whatToShow[, filter]]);
  ///
  /// const nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   {
  ///    acceptNode(node) {
  ///     return node.nodeName.toLowerCase() === 'p' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
  ///    }
  ///   }
  /// );
  /// const pars = [];
  /// let currentNode;
  ///
  /// while (currentNode = nodeIterator.nextNode()) {
  ///  pars.push(currentNode);
  /// }
  ///
  external NodeIterator createNodeIterator(Node root,
      [int? whatToShow = 0xFFFFFFFF, NodeFilter? filter]);

  /// Creates a [TreeWalker] object.
  ///
  /// document.createTreeWalker(root[, whatToShow[, filter[, expandEntityReferences]]]);
  ///
  ///
  ///  The following example goes through all nodes in the body,
  ///  filters out any non nodes that aren't elements (with the `NodeFilter.SHOW_ELEMENT` value),
  ///  marks each remaining node as acceptable (The acceptNode() method could make
  ///  a different decision.), and then makes use of tree walker iterator
  ///  that is created to advance through the nodes (now all elements) and push them into an
  ///  array.
  ///
  /// var treeWalker = document.createTreeWalker(
  ///  document.body,
  ///  NodeFilter.SHOW_ELEMENT,
  ///  { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///  false
  /// );
  ///
  /// var nodeList = [];
  /// var currentNode = treeWalker.currentNode;
  ///
  /// while(currentNode) {
  ///  nodeList.push(currentNode);
  ///  currentNode = treeWalker.nextNode();
  /// }
  ///
  external TreeWalker createTreeWalker(Node root,
      [int? whatToShow = 0xFFFFFFFF, NodeFilter? filter]);
  external bool get hidden;
  external VisibilityState get visibilityState;
  external EventHandlerNonNull? get onvisibilitychange;
  external set onvisibilitychange(EventHandlerNonNull? newValue);
  external Promise<bool> hasStorageAccess();
  external Promise<Object> requestStorageAccess();
  external Selection? getSelection();
  external DocumentTimeline get timeline;
  external Element? elementFromPoint(double x, double y);
  external Iterable<Element> elementsFromPoint(double x, double y);
  external CaretPosition? caretPositionFromPoint(double x, double y);
  external Element? get scrollingElement;
  external EventHandlerNonNull? get onpointerlockchange;
  external set onpointerlockchange(EventHandlerNonNull? newValue);
  external EventHandlerNonNull? get onpointerlockerror;
  external set onpointerlockerror(EventHandlerNonNull? newValue);
  external Object exitPointerLock();
  external bool get fullscreenEnabled;
  external bool get fullscreen;
  external Promise<Object> exitFullscreen();
  external EventHandlerNonNull? get onfullscreenchange;
  external set onfullscreenchange(EventHandlerNonNull? newValue);
  external EventHandlerNonNull? get onfullscreenerror;
  external set onfullscreenerror(EventHandlerNonNull? newValue);
  external bool get pictureInPictureEnabled;
  external Promise<Object> exitPictureInPicture();
  external EventHandlerNonNull? get onfreeze;
  external set onfreeze(EventHandlerNonNull? newValue);
  external EventHandlerNonNull? get onresume;
  external set onresume(EventHandlerNonNull? newValue);
  external bool get wasDiscarded;
  external NamedFlowMap get namedFlows;
  external SVGSVGElement? get rootElement;
  external FragmentDirective get fragmentDirective;
  external Promise<InterestCohort> interestCohort();
  external PermissionsPolicy get permissionsPolicy;
  external Location? get location;
  external String get domain;
  external set domain(String newValue);
  external String get referrer;
  external String get cookie;
  external set cookie(String newValue);
  external String get lastModified;
  external DocumentReadyState get readyState;
  external String get title;
  external set title(String newValue);
  external String get dir;
  external set dir(String newValue);
  HTMLElement? get body => js_util.getProperty(this, 'body');
  external set body(HTMLElement? newValue);
  external HTMLHeadElement? get head;
  external HTMLCollection get images;
  external HTMLCollection get embeds;
  external HTMLCollection get plugins;
  external HTMLCollection get links;
  external HTMLCollection get forms;
  external HTMLCollection get scripts;
  external NodeList getElementsByName(String elementName);
  external dynamic get currentScript;
  external Window? open(String url, [String? name, String features]);
  external Object close();
  external Object write([String text]);
  external Object writeln([String text]);
  external Window? get defaultView;
  external bool hasFocus();
  external String get designMode;
  external set designMode(String newValue);
  external bool execCommand(String commandId,
      [bool? showUI = false, String? value = '']);
  external bool queryCommandEnabled(String commandId);
  external bool queryCommandIndeterm(String commandId);
  external bool queryCommandState(String commandId);
  external bool queryCommandSupported(String commandId);
  external String queryCommandValue(String commandId);
  external EventHandlerNonNull? get onreadystatechange;
  external set onreadystatechange(EventHandlerNonNull? newValue);
  external String get fgColor;
  external set fgColor(String newValue);
  external String get linkColor;
  external set linkColor(String newValue);
  external String get vlinkColor;
  external set vlinkColor(String newValue);
  external String get alinkColor;
  external set alinkColor(String newValue);
  external String get bgColor;
  external set bgColor(String newValue);
  external HTMLCollection get anchors;
  external HTMLCollection get applets;
  external Object clear();
  external Object captureEvents();
  external Object releaseEvents();
  external HTMLAllCollection get all;
  external FontMetrics measureElement(Element element);
  external FontMetrics measureText(
      String text, StylePropertyMapReadOnly styleMap);
}

///  The XMLDocument interface represents an XML document. It
/// inherits from the generic [Document] and does not add any
/// specific methods or properties to it: nevertheless, several
/// algorithms behave differently with the two types of documents.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Document
///
///
///
///
///
///    XMLDocument
///
///
@JS()
@staticInterop
class XMLDocument implements Document {
  external factory XMLDocument();
}

@anonymous
@JS()
@staticInterop
class ElementCreationOptions {
  external factory ElementCreationOptions({String mIs});
}

extension PropsElementCreationOptions on ElementCreationOptions {
  @JS('is')
  @staticInterop
  external String get mIs;
  external set mIs(String newValue);
}

///  The interface represents an object providing methods which are
/// not dependent on any particular document. Such an object is
/// returned by the [Document.implementation] property.
@JS()
@staticInterop
class DOMImplementation {
  external factory DOMImplementation();
}

extension PropsDOMImplementation on DOMImplementation {
  /// Creates and returns a [DocumentType].
  ///
  /// var doctype = document.implementation.createDocumentType(qualifiedNameStr, publicId, systemId);
  ///
  /// var dt = document.implementation.createDocumentType('svg:svg', '-//W3C//DTD SVG 1.1//EN', 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd');
  /// var d = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg:svg', dt);
  /// alert(d.doctype.publicId); // -//W3C//DTD SVG 1.1//EN
  ///
  external DocumentType createDocumentType(
      String qualifiedName, String publicId, String systemId);

  /// Creates and returns an [XMLDocument].
  ///
  /// var doc = document.implementation.createDocument(namespaceURI, qualifiedNameStr, documentType);
  ///
  /// var doc = document.implementation.createDocument ('http://www.w3.org/1999/xhtml', 'html', null);
  /// var body = document.createElementNS('http://www.w3.org/1999/xhtml', 'body');
  /// body.setAttribute('id', 'abc');
  /// doc.documentElement.appendChild(body);
  /// alert(doc.getElementById('abc')); // [object HTMLBodyElement]
  ///
  external XMLDocument createDocument(String? namespace, String qualifiedName,
      [DocumentType? doctype]);

  /// Creates and returns an HTML [Document].
  ///
  /// const newDoc = document.implementation.createHTMLDocument(title)
  ///
  /// This example creates a new HTML document and inserts it into an <iframe> in the current document.
  /// Here's the HTML for this example:
  /// <body>
  ///  <p>Click <a href="javascript:makeDocument()">here</a> to create a new document and insert it below.</p>
  ///  <iframe id="theFrame" src="about:blank" />
  /// </body>
  ///
  /// The JavaScript implementation of makeDocument() follows:
  /// function makeDocument() {
  ///  let frame = document.getElementById("theFrame");
  ///
  ///  let doc = document.implementation.createHTMLDocument("New Document");
  ///  let p = doc.createElement("p");
  ///  p.textContent = "This is a new paragraph.";
  ///
  ///  try {
  ///   doc.body.appendChild(p);
  ///  } catch(e) {
  ///   console.log(e);
  ///  }
  ///
  ///  // Copy the new HTML document into the frame
  ///
  ///  let destDocument = frame.contentDocument;
  ///  let srcNode = doc.documentElement;
  ///  let newNode = destDocument.importNode(srcNode, true);
  ///
  ///  destDocument.replaceChild(newNode, destDocument.documentElement);
  /// }
  ///  The code in lines 4–12 handle creating the new HTML document and inserting some content
  ///  into it. Line 4 uses createHTMLDocument() to construct a new HTML document
  ///  whose <title> is "New Document". Lines 5 and 6 create a
  ///  new paragraph element with some simple content, and then lines 8–12 handle inserting the
  ///  new paragraph into the new document.
  ///  Line 16 pulls the contentDocument of the frame; this is the document into
  ///  which we'll be injecting the new content. The next two lines handle importing the
  ///  contents of our new document into the new document's context. Finally, line 20 actually
  ///  replaces the contents of the frame with the new document's contents.
  ///
  /// View Live Examples
  /// The returned document is pre-constructed with the following HTML:
  /// <!doctype html>
  /// <html>
  /// <head>
  /// <title>title</title>
  /// </head>
  /// <body>
  /// </body>
  /// </html>
  ///
  external Document createHTMLDocument([String? title]);

  ///  Returns a boolean value indicating if a given feature is
  /// supported or not. This function is unreliable and kept for
  /// compatibility purpose alone: except for SVG-related queries, it
  /// always returns [true]. Old browsers are very inconsistent in
  /// their behavior.
  ///
  /// const flag = document.implementation.hasFeature(feature, version);
  ///
  external bool hasFeature();
}

/// The interface represents a [Node] containing a doctype.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    DocumentType
///
///
@JS()
@staticInterop
class DocumentType implements Node, ChildNode {
  external factory DocumentType();
}

extension PropsDocumentType on DocumentType {
  /// A [DOMString], eg ["html"] for [<!DOCTYPE HTML>].
  ///
  external String get name;

  ///  A [DOMString], eg ["-//W3C//DTD HTML 4.01//EN"], empty string
  /// for HTML5.
  ///
  external String get publicId;

  ///  A [DOMString], eg ["http://www.w3.org/TR/html4/strict.dtd"],
  /// empty string for HTML5.
  ///
  external String get systemId;
}

///  The interface represents a minimal document object that has no
/// parent.
///  It is used as a lightweight version of [Document] that stores a
/// segment of a document structure comprised of nodes just like a
/// standard document. The key difference is due to the fact that the
/// document fragment isn't part of the active document tree
/// structure. Changes made to the fragment don't affect the document
/// (even on reflow) or incur any performance impact when changes are
/// made.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    DocumentFragment
///
///
@JS()
@staticInterop
class DocumentFragment implements Node, NonElementParentNode, ParentNode {
  external factory DocumentFragment();
}

///  The interface of the Shadow DOM API is the root node of a DOM
/// subtree that is rendered separately from a document's main DOM
/// tree.
///  You can retrieve a reference to an element's shadow root using
/// its [Element.shadowRoot] property, provided it was created using
/// [Element.attachShadow()] with the [mode] option set to [open].
@JS()
@staticInterop
class ShadowRoot implements DocumentFragment, DocumentOrShadowRoot, InnerHTML {
  external factory ShadowRoot();
}

extension PropsShadowRoot on ShadowRoot {
  ///
  ///    The mode of the [ShadowRoot] — either [open] or [closed].
  ///     This defines whether or not the shadow root's internal
  /// features are accessible from JavaScript.
  ///
  ///
  external ShadowRootMode get mode;

  ///  Returns a boolean that indicates whether was set when the shadow
  /// was attached (see [Element.attachShadow()]).
  ///
  @deprecated
  external bool get delegatesFocus;
  external SlotAssignmentMode get slotAssignment;

  ///  Returns a reference to the DOM element the [ShadowRoot] is
  /// attached to.
  ///
  external Element get host;
  external EventHandlerNonNull? get onslotchange;
  external set onslotchange(EventHandlerNonNull? newValue);
}

enum ShadowRootMode { open, closed }

enum SlotAssignmentMode { manual, named }

///   is the most general base class from which all element objects
/// (i.e. objects that represent elements) in a [Document] inherit.
/// It only has methods and properties common to all kinds of
/// elements. More specific classes inherit from .
///  For example, the [HTMLElement] interface is the base interface
/// for HTML elements, while the [SVGElement] interface is the basis
/// for all SVG elements. Most functionality is specified further
/// down the class hierarchy.
///  Languages outside the realm of the Web platform, like XUL
/// through the [XULElement] interface, also implement .
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Element
///
///
@JS()
@staticInterop
class Element
    implements
        Node,
        Animatable,
        ARIAMixin,
        GeometryUtils,
        Region,
        ParentNode,
        NonDocumentTypeChildNode,
        ChildNode,
        Slottable,
        InnerHTML {
  external factory Element();
}

extension PropsElement on Element {
  ///  The namespace URI of the element, or [null] if it is no
  /// namespace.
  ///
  ///     Note: In Firefox 3.5 and earlier, HTML elements are in no
  /// namespace. In later versions, HTML elements are in the
  /// [http://www.w3.org/1999/xhtml] namespace in both HTML and XML
  /// trees.
  ///
  ///
  external String? get namespaceURI;

  ///  A [DOMString] representing the namespace prefix of the element,
  /// or [null] if no prefix is specified.
  ///
  external String? get prefix;

  ///  A [DOMString] representing the local part of the qualified name
  /// of the element.
  ///
  external String get localName;

  ///  Returns a [String] with the name of the tag for the given
  /// element.
  ///
  external String get tagName;

  /// Is a [DOMString] representing the id of the element.
  ///
  external String get id;
  external set id(String newValue);

  /// Is a [DOMString] representing the class of the element.
  ///
  external dynamic get className;
  external set className(dynamic newValue);

  ///  Returns a [DOMTokenList] containing the list of class
  /// attributes.
  ///
  external DOMTokenList get classList;

  ///  Returns the name of the shadow DOM slot the element is inserted
  /// in.
  ///
  @experimental
  external String get slot;
  external set slot(String newValue);

  ///  Returns a boolean value indicating if the element has one or
  /// more HTML attributes present.
  ///
  /// var result = element.hasAttributes();
  ///
  external bool hasAttributes();

  ///  Returns a [NamedNodeMap] object containing the assigned
  /// attributes of the corresponding HTML element.
  ///
  external NamedNodeMap get attributes;

  /// Returns an array of attribute names from the current element.
  ///
  /// let attributeNames = element.getAttributeNames();
  ///
  /// The following example shows how:
  ///
  ///  For an attribute which has a namespace prefix, getAttributeNames() returns that namespace prefix along with the attribute name.
  ///  For an attribute which has no namespace prefix, getAttributeNames() returns just the attribute name, as-is.
  ///
  /// It’s important to understand that:
  ///
  ///  An attribute can be present in the DOM with a namespace but lacking a namespace prefix.
  ///  For an attribute in the DOM that has a namespace but lacks a namespace prefix, getAttributeNames() will return just the attribute name, with no indication that the attribute is in a namespace.
  ///
  /// The example below includes such a “namespaced but without a namespace prefix” case.
  /// const element = document.createElement('a')
  ///
  /// // set "href" attribute with no namespace and no namespace prefix
  /// element.setAttribute('href', 'https://example.com')
  /// // set "href" attribute with namespace and also "xlink" namespace prefix
  /// element.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', 'https://example.com')
  /// // set "show" attribute with namespace but no namespace prefix
  /// element.setAttributeNS('http://www.w3.org/1999/xlink', 'show', 'new')
  ///
  /// // Iterate over element's attributes
  /// for (let name of element.getAttributeNames()) {
  ///  let value = element.getAttribute(name);
  ///  console.log(name, value);
  /// }
  ///
  /// // logs:
  /// // href https://example.com
  /// // xlink:href https://example.com
  /// // show new
  ///
  external Iterable<String> getAttributeNames();

  ///  Retrieves the value of the named attribute from the current node
  /// and returns it as a string.
  ///
  /// let attribute = element.getAttribute(attributeName);
  ///
  /// where
  ///
  ///
  ///   attribute is a string containing the value of
  ///   attributeName.
  ///
  ///
  ///   attributeName is the name of the attribute whose value you
  ///   want to get.
  ///
  ///
  external String? getAttribute(String qualifiedName);

  ///  Retrieves the value of the attribute with the specified
  /// namespace and name from the current node and returns it as a
  /// string.
  ///
  /// attrVal = element.getAttributeNS(namespace, name)
  ///
  external String? getAttributeNS(String? namespace, String localName);

  /// Sets the value of a named attribute of the current node.
  ///
  /// Element.setAttribute(name, value);
  ///
  ///
  ///  In the following example, setAttribute() is used to set attributes on a
  ///  <button>.
  ///
  /// <button>Hello World</button>
  ///
  /// ```
  ///
  /// var b = document.querySelector("button");
  ///
  /// b.setAttribute("name", "helloButton");
  /// b.setAttribute("disabled", "");
  ///
  /// ```
  ///
  /// This demonstrates two things:
  ///
  ///
  ///   The first call to setAttribute() above shows changing the name attribute's value to "helloButton".
  ///   You can see this using your browser's page inspector (Chrome,
  ///   Edge,
  ///   Firefox, Safari).
  ///
  ///
  ///   To set the value of a Boolean attribute, such as disabled, you can specify any value.
  ///   An empty string or the name of the attribute are recommended values.
  ///   All that matters is that if the attribute is present at all, regardless of its actual value, its value is considered to be true.
  ///   The absence of the attribute means its value is false. By setting the value of the disabled attribute to the empty string (""), we are setting disabled to true, which results in the button being disabled.
  ///
  ///
  /// DOM methods dealing with element's attributes:
  ///
  /// Not namespace-aware, most commonly used methods
  /// Namespace-aware variants (DOM Level 2)
  /// DOM Level 1 methods for dealing with Attr nodes directly (seldom used)
  /// DOM Level 2 namespace-aware methods for dealing with Attr nodes directly (seldom used)
  ///
  ///
  /// setAttribute (DOM 1)
  /// setAttributeNS
  /// setAttributeNode
  /// setAttributeNodeNS
  /// getAttribute (DOM 1)
  /// getAttributeNS
  /// getAttributeNode
  /// getAttributeNodeNS
  /// hasAttribute (DOM 2)
  /// hasAttributeNS
  /// -
  /// -
  /// removeAttribute (DOM 1)
  /// removeAttributeNS
  /// removeAttributeNode
  /// -
  ///
  external Object setAttribute(String qualifiedName, String value);

  ///  Sets the value of the attribute with the specified name and
  /// namespace, from the current node.
  ///
  /// element.setAttributeNS(namespace, name, value)
  ///  namespace is a string specifying the namespace of the attribute.
  ///
  ///   name is a string identifying the attribute by its qualified name;
  ///   that is, a namespace prefix followed by a colon followed by a local name.
  ///
  ///  value is the desired string value of the new attribute.
  ///
  /// let d = document.getElementById('d1');
  /// d.setAttributeNS('http://www.mozilla.org/ns/specialspace', 'spec:align', 'center');
  ///
  external Object setAttributeNS(
      String? namespace, String qualifiedName, String value);

  /// Removes the named attribute from the current node.
  ///
  /// element.removeAttribute(attrName);
  ///
  /// // Given: <div id="div1" align="left" width="200px">
  /// document.getElementById("div1").removeAttribute("align");
  /// // Now: <div id="div1" width="200px">
  ///
  external Object removeAttribute(String qualifiedName);

  ///  Removes the attribute with the specified name and namespace,
  /// from the current node.
  ///
  /// element.removeAttributeNS(namespace, attrName);
  ///
  /// // Given:
  /// //  <div id="div1" xmlns:special="http://www.mozilla.org/ns/specialspace"
  /// //   special:specialAlign="utterleft" width="200px" />
  /// d = document.getElementById("div1");
  /// d.removeAttributeNS("http://www.mozilla.org/ns/specialspace", "specialAlign");
  /// // Now: <div id="div1" width="200px" />
  ///
  external Object removeAttributeNS(String? namespace, String localName);

  ///  Toggles a boolean attribute, removing it if it is present and
  /// adding it if it is not present, on the specified element.
  ///
  /// toggleAttribute(name);
  /// toggleAttribute(name, force);
  ///
  ///
  ///  In the following example, toggleAttribute() is used to toggle the
  ///  disabled attribute of an <input>.
  ///
  /// <input value="text">
  /// <button>toggleAttribute("disabled")</button>
  ///
  /// ```
  ///
  /// var button = document.querySelector("button");
  /// var input = document.querySelector("input");
  ///
  /// button.addEventListener("click", function(){
  ///  input.toggleAttribute("disabled");
  /// });
  ///
  /// ```
  ///
  external bool toggleAttribute(String qualifiedName, [bool? force]);

  ///  Returns a boolean value indicating if the element has the
  /// specified attribute or not.
  ///
  /// var result = element.hasAttribute(name);
  ///  result
  ///
  ///   holds the return value true or false.
  ///
  ///  name
  ///
  ///   is a string representing the name of the attribute.
  ///
  ///
  /// var foo = document.getElementById("foo");
  /// if (foo.hasAttribute("bar")) {
  ///   // do something
  /// }
  ///
  external bool hasAttribute(String qualifiedName);

  ///  Returns a boolean value indicating if the element has the
  /// specified attribute, in the specified namespace, or not.
  ///
  /// result = element.hasAttributeNS(namespace,localName)
  ///  result is the boolean value true or false.
  ///  namespace is a string specifying the namespace of the attribute.
  ///  localName is the name of the attribute.
  ///
  /// // Check that the attribute exists before you set a value
  /// var d = document.getElementById("div1");
  /// if (d.hasAttributeNS(
  ///     "http://www.mozilla.org/ns/specialspace/",
  ///     "special-align")) {
  ///  d.setAttribute("align", "center");
  /// }
  ///
  external bool hasAttributeNS(String? namespace, String localName);

  ///  Retrieves the node representation of the named attribute from
  /// the current node and returns it as an [Attr].
  ///
  /// var attrNode = element.getAttributeNode(attrName);
  ///  attrNode is an Attr node for the attribute.
  ///  attrName is a string containing the name of the attribute.
  ///
  /// // html: <div id="top" />
  /// let t = document.getElementById("top");
  /// let idAttr = t.getAttributeNode("id");
  /// alert(idAttr.value == "top")
  ///
  external Attr? getAttributeNode(String qualifiedName);

  ///  Retrieves the node representation of the attribute with the
  /// specified name and namespace, from the current node and returns
  /// it as an [Attr].
  ///
  /// attributeNode = element.getAttributeNodeNS(namespace, nodeName)
  ///  attributeNode is the node for specified attribute.
  ///  namespace is a string specifying the namespace of the attribute.
  ///  nodeName is a string specifying the name of the attribute.
  ///
  external Attr? getAttributeNodeNS(String? namespace, String localName);

  ///  Sets the node representation of the named attribute from the
  /// current node.
  ///
  /// var replacedAttr = element.setAttributeNode(attribute);
  ///  attribute is the Attr node to set on the element.
  ///
  ///   replacedAttr is the replaced attribute node, if any, returned by this
  ///   function.
  ///
  ///
  /// This example copies the align attribute from one element to another.
  /// <div id="one" align="left">one</div>
  /// <div id="two">two</div>
  ///
  /// ```
  ///
  /// let d1 = document.getElementById('one');
  /// let d2 = document.getElementById('two');
  /// let a = d1.getAttributeNode('align');
  ///
  /// d2.setAttributeNode(a.cloneNode(true));
  ///
  /// // Returns: 'left'
  /// alert(d2.attributes[1].value);
  ///
  /// ```
  ///
  external Attr? setAttributeNode(Attr attr);

  ///  Sets the node representation of the attribute with the specified
  /// name and namespace, from the current node.
  ///
  /// replacedAttr = element.setAttributeNodeNS(attributeNode)
  ///  replacedAttr is the replaced attribute node, if any, returned by this function.
  ///  attributeNode is an Attr node.
  ///
  /// // <div id="one" xmlns:myNS="http://www.mozilla.org/ns/specialspace"
  /// //      myNS:special-align="utterleft">one</div>
  /// // <div id="two">two</div>
  ///
  /// var myns = "http://www.mozilla.org/ns/specialspace";
  /// var d1 = document.getElementById("one");
  /// var d2 = document.getElementById("two");
  /// var a = d1.getAttributeNodeNS(myns, "special-align");
  /// d2.setAttributeNodeNS(a.cloneNode(true));
  /// alert(d2.attributes[1].value) // returns: `utterleft'
  ///
  external Attr? setAttributeNodeNS(Attr attr);

  ///  Removes the node representation of the named attribute from the
  /// current node.
  ///
  /// removedAttr = element.removeAttributeNode(attributeNode)
  ///  attributeNode is the Attr node that needs to be removed.
  ///  removedAttr is the removed Attr node.
  ///
  /// // Given: <div id="top" align="center" />
  /// var d = document.getElementById("top");
  /// var d_align = d.getAttributeNode("align");
  /// d.removeAttributeNode(d_align);
  /// // align is now removed: <div id="top" />
  ///
  external Attr removeAttributeNode(Attr attr);

  ///  Attaches a shadow DOM tree to the specified element and returns
  /// a reference to its [ShadowRoot].
  ///
  /// attachShadow(init)
  ///
  external ShadowRoot attachShadow(ShadowRootInit init);

  ///  Returns the open shadow root that is hosted by the element, or
  /// null if no open shadow root is present.
  ///
  external ShadowRoot? get shadowRoot;

  ///  Returns the [Element] which is the closest ancestor of the
  /// current element (or the current element itself) which matches the
  /// selectors given in parameter.
  ///
  /// var closestElement = targetElement.closest(selectors);
  ///
  external Element? closest(String selectors);

  ///  Returns a boolean value indicating whether or not the element
  /// would be selected by the specified selector string.
  ///
  /// var result = element.matches(selectorString);
  ///
  /// <ul id="birds">
  ///  <li>Orange-winged parrot</li>
  ///  <li class="endangered">Philippine eagle</li>
  ///  <li>Great white pelican</li>
  /// </ul>
  ///
  /// <script type="text/javascript">
  ///  var birds = document.getElementsByTagName('li');
  ///
  ///  for (var i = 0; i < birds.length; i++) {
  ///   if (birds[i].matches('.endangered')) {
  ///    console.log('The ' + birds[i].textContent + ' is endangered!');
  ///   }
  ///  }
  /// </script>
  ///  This will log "The Philippine eagle is endangered!" to the console, since the element
  ///  has indeed a class attribute with value endangered.
  ///
  external bool matches(String selectors);
  external bool webkitMatchesSelector(String selectors);

  ///  Returns a live [HTMLCollection] containing all descendant
  /// elements, of a particular tag name, from the current element.
  ///
  /// elements = element.getElementsByTagName(tagName)
  ///
  ///   elements is a live HTMLCollection of elements
  ///   with a matching tag name, in the order they appear. If no elements are found, the
  ///   HTMLCollection is empty.
  ///
  ///
  ///   element is the element from where the search starts. Only the
  ///   element's descendants are included, not the element itself.
  ///
  ///
  ///   tagName is the qualified name to look for. The special string
  ///   "*" represents all elements. For compatibility with XHTML, lower-case
  ///   should be used.
  ///
  ///
  /// // Check the status of each data cell in a table
  /// const table = document.getElementById('forecast-table');
  /// const cells = table.getElementsByTagName('td');
  ///
  /// for (let cell of cells) {
  ///  let status = cell.getAttribute('data-status');
  ///  if (status === 'open') {
  ///   // Grab the data
  ///  }
  /// }
  ///
  external HTMLCollection getElementsByTagName(String qualifiedName);

  ///  Returns a live [HTMLCollection] containing all descendant
  /// elements, of a particular tag name and namespace, from the
  /// current element.
  ///
  /// elements = element.getElementsByTagNameNS(namespaceURI, localName)
  ///
  ///   elements is a live HTMLCollection of found elements in
  ///   the order they appear in the tree.
  ///
  ///
  ///   element is the element from where the search should start. Note that
  ///   only the descendants of this element are included in the search, not the node itself.
  ///
  ///
  ///   namespaceURI is the namespace URI of elements to look for (see
  ///   Element.namespaceURI and Attr.namespaceURI). For
  ///   example, if you need to look for XHTML elements, use the XHTML namespace URI,
  ///   http://www.w3.org/1999/xhtml.
  ///
  ///
  ///   localName is either the local name of elements to look for or the
  ///   special value "*", which matches all elements (see
  ///   Element.localName and Attr.localName).
  ///
  ///
  /// // check the alignment on a number of cells in a table in an XHTML document.
  /// var table = document.getElementById("forecast-table");
  /// var cells = table.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "td");
  ///
  /// for (var i = 0; i < cells.length; i++) {
  ///   var axis = cells[i].getAttribute("axis");
  ///   if (axis == "year") {
  ///     // grab the data
  ///   }
  /// }
  ///
  external HTMLCollection getElementsByTagNameNS(
      String? namespace, String localName);

  ///  Returns a live [HTMLCollection] that contains all descendants of
  /// the current element that possess the list of classes given in the
  /// parameter.
  ///
  /// var elements = element.getElementsByClassName(names);
  ///
  external HTMLCollection getElementsByClassName(String classNames);

  ///  Inserts a given element node at a given position relative to the
  /// element it is invoked upon.
  ///
  /// targetElement.insertAdjacentElement(position, element);
  ///
  /// beforeBtn.addEventListener('click', function() {
  ///  var tempDiv = document.createElement('div');
  ///  tempDiv.style.backgroundColor = randomColor();
  ///  if (activeElem) {
  ///   activeElem.insertAdjacentElement('beforebegin', tempDiv);
  ///  }
  ///  setListener(tempDiv);
  /// });
  ///
  /// afterBtn.addEventListener('click', function() {
  ///  var tempDiv = document.createElement('div');
  ///  tempDiv.style.backgroundColor = randomColor();
  ///  if (activeElem) {
  ///   activeElem.insertAdjacentElement('afterend', tempDiv);
  ///  }
  ///  setListener(tempDiv);
  /// });
  ///  Have a look at our insertAdjacentElement.html
  ///  demo on GitHub (see the source
  /// code too.) Here, we have a sequence of <div> elements inside a
  ///  container. When one is clicked, it becomes selected and you can then press the
  ///  Insert before and Insert after buttons to insert new divs before or
  ///  after the selected element using insertAdjacentElement().
  ///
  external Element? insertAdjacentElement(String where, Element element);

  ///  Inserts a given text node at a given position relative to the
  /// element it is invoked upon.
  ///
  /// element.insertAdjacentText(where, data);
  ///
  /// beforeBtn.addEventListener('click', function() {
  ///  para.insertAdjacentText('afterbegin',textInput.value);
  /// });
  ///
  /// afterBtn.addEventListener('click', function() {
  ///  para.insertAdjacentText('beforeend',textInput.value);
  /// });
  ///  Have a look at our insertAdjacentText.html
  ///  demo on GitHub (see the source
  /// code too.) Here we have a simple paragraph. You can enter some text into the form
  ///  element, then press the Insert before and Insert after buttons to
  ///  insert it before or after the existing paragraph text using
  ///  insertAdjacentText(). Note that the existing text node is not added to —
  ///  further text nodes are created containing the new additions.
  ///
  external Object insertAdjacentText(String where, String data);
  external StylePropertyMapReadOnly computedStyleMap();
  external DOMRectList getClientRects();
  external DOMRect getBoundingClientRect();
  external Object scrollIntoView([dynamic arg]);
  external Object scroll(
      [/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]);
  external Object scrollTo(
      [/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]);
  external Object scrollBy(
      [/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]);
  external /* double | NaN */ dynamic get scrollTop;
  external set scrollTop(/* double | NaN */ dynamic newValue);
  external /* double | NaN */ dynamic get scrollLeft;
  external set scrollLeft(/* double | NaN */ dynamic newValue);
  external int get scrollWidth;
  external int get scrollHeight;
  external int get clientTop;
  external int get clientLeft;
  external int get clientWidth;
  external int get clientHeight;
  external Object requestPointerLock();
  external Promise<Object> requestFullscreen([FullscreenOptions? options]);
  external EventHandlerNonNull? get onfullscreenchange;
  external set onfullscreenchange(EventHandlerNonNull? newValue);
  external EventHandlerNonNull? get onfullscreenerror;
  external set onfullscreenerror(EventHandlerNonNull? newValue);
  external Object setPointerCapture(int pointerId);
  external Object releasePointerCapture(int pointerId);
  external bool hasPointerCapture(int pointerId);
  external CSSPseudoElement? pseudo(String type);
  external String get outerHTML;
  external set outerHTML(String newValue);
  external Object insertAdjacentHTML(String position, String text);
  external String get elementTiming;
  external set elementTiming(String newValue);
  external Node getSpatialNavigationContainer();
  external Iterable<Node> focusableAreas([FocusableAreasOption? option]);
  external Node? spatialNavigationSearch(SpatialNavigationDirection dir,
      [SpatialNavigationSearchOptions? options]);
  @JS('part')
  @staticInterop
  external DOMTokenList get mPart;
}

@anonymous
@JS()
@staticInterop
class ShadowRootInit {
  external factory ShadowRootInit(
      {ShadowRootMode mode,
      bool delegatesFocus = false,
      SlotAssignmentMode slotAssignment = SlotAssignmentMode.named});
}

extension PropsShadowRootInit on ShadowRootInit {
  external ShadowRootMode get mode;
  external set mode(ShadowRootMode newValue);
  external bool get delegatesFocus;
  external set delegatesFocus(bool newValue);
  external SlotAssignmentMode get slotAssignment;
  external set slotAssignment(SlotAssignmentMode newValue);
}

///  The interface represents a collection of [Attr] objects. Objects
/// inside a are not in any particular order, unlike [NodeList],
/// although they may be accessed by an index as in an array.
///  A object is live and will thus be auto-updated if changes are
/// made to its contents internally or elsewhere.
///
///   Note: Although called , this interface doesn't deal with [Node]
/// objects but with [Attr] objects, which were originally a
/// specialized class of [Node], and still are in some
/// implementations.
///
@JS()
@staticInterop
class NamedNodeMap {
  external factory NamedNodeMap();
}

extension PropsNamedNodeMap on NamedNodeMap {
  /// Returns the amount of objects in the map.
  ///
  external int get length;

  ///  Returns the [Attr] at the given index, or [null] if the index is
  /// higher or equal to the number of nodes.
  ///
  external Attr? item(int index);

  /// Returns a [Attr], corresponding to the given name.
  ///
  /// myAttr = attrs.getNamedItem(name)
  ///
  external Attr? getNamedItem(String qualifiedName);

  ///  Returns a [Attr] identified by a namespace and related local
  /// name.
  ///
  external Attr? getNamedItemNS(String? namespace, String localName);

  ///  Replaces, or adds, the [Attr] identified in the map by the given
  /// name.
  ///
  external Attr? setNamedItem(Attr attr);

  ///  Replaces, or adds, the [Attr] identified in the map by the given
  /// namespace and related local name.
  ///
  external Attr? setNamedItemNS(Attr attr);

  /// Removes the [Attr] identified by the given map.
  ///
  external Attr removeNamedItem(String qualifiedName);

  ///  Removes the [Attr] identified by the given namespace and related
  /// local name.
  ///
  external Attr removeNamedItemNS(String? namespace, String localName);
}

///  The interface represents one of an element's attributes as an
/// object. In most situations, you will directly retrieve the
/// attribute value as a string (e.g., [Element.getAttribute()]), but
/// certain functions (e.g., [Element.getAttributeNode()]) or means
/// of iterating return instances.
///  The core idea of an object of type is the association between a
/// name and a value. An attribute may also be part of a namespace
/// and, in this case, it also has a URI identifying the namespace,
/// and a prefix that is an abbreviation for the namespace.
///  The name is deemed local when it ignores the eventual namespace
/// prefix and deemed qualified when it includes the prefix of the
/// namespace, if any, separated from the local name by a colon
/// ([:]). We have three cases: an attribute outside of a namespace,
/// an attribute inside a namespace without a prefix defined, an
/// attribute inside a namespace with a prefix:
///
///
///
///    Attribute
///    Namespace name
///    Namespace prefix
///    Attribute local name
///    Attribute qualified name
///
///
///
///
///    [myAttr]
///    none
///    none
///    [myAttr]
///    [myAttr]
///
///
///    [myAttr]
///    [mynamespace]
///    none
///    [myAttr]
///    [myAttr]
///
///
///    [myAttr]
///    [mynamespace]
///    [myns]
///    [myAttr]
///    [myns:myAttr]
///
///
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Attr
///
///
///
///   Note: This interface represents only attributes present in the
/// tree representation of the [Element], being a SVG, an HTML or a
/// MathML element. It doesn't represent the property of an interface
/// associated with such element, such as [HTMLTableElement] for a
/// [<table>] element. (See this article for more information about
/// attributes and how they are reflected into properties.)
///
@JS()
@staticInterop
class Attr implements Node {
  external factory Attr();
}

extension PropsAttr on Attr {
  ///  A [String] representing the URI of the namespace of the
  /// attribute, or [null] if there is no namespace.
  ///
  external String? get namespaceURI;

  ///  A [String] representing the namespace prefix of the attribute,
  /// or [null] if a namespace without prefix or no namespace are
  /// specified.
  ///
  external String? get prefix;

  ///  A [String] representing the local part of the qualified name of
  /// the attribute.
  ///
  external String get localName;

  ///  The attribute's qualified name. If the attribute is not in a
  /// namespace, it will be the same as [localName] property.
  ///
  external String get name;

  ///  The attribute's value, a string that can be set and get using
  /// this property.
  ///
  external String get value;
  external set value(String newValue);

  /// The [Element] the attribute belongs to.
  ///
  external Element? get ownerElement;

  /// This property always returns [true].
  ///
  @deprecated
  external bool get specified;
}

///  The abstract interface represents a [Node] object that contains
/// characters. This is an abstract interface, meaning there aren't
/// any objects of type : it is implemented by other interfaces like
/// [Text], [Comment], [CDATASection], or [ProcessingInstruction],
/// which aren't abstract.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
@JS()
@staticInterop
class CharacterData implements Node, NonDocumentTypeChildNode, ChildNode {
  external factory CharacterData();
}

extension PropsCharacterData on CharacterData {
  ///  Is a string representing the textual data contained in this
  /// object.
  ///
  external String get data;
  external set data(String newValue);

  ///  Returns a number representing the size of the string contained
  /// in the object.
  ///
  external int get length;

  ///  Returns a [String] containing the part of [CharacterData.data]
  /// of the specified length and starting at the specified offset.
  ///
  ///  domString = characterData.substringData(offset, count)
  ///
  external String substringData(int offset, int count);

  ///  Appends the given string to the [CharacterData.data] string;
  /// when this method returns, [data] contains the concatenated
  /// [DOMString].
  ///
  /// appendData(data);
  ///
  /// <span>Result: </span>A text
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.appendData(" - appended text.");
  ///
  external Object appendData(String data);

  ///  Inserts the specified characters, at the specified offset, in
  /// the [CharacterData.data] string; when this method returns, [data]
  /// contains the modified [DOMString].
  ///
  /// characterData.insertData(offset, data)
  ///
  /// <span>Result: </span>A string.
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.insertData(2, "long ");
  ///
  external Object insertData(int offset, String data);

  ///  Removes the specified amount of characters, starting at the
  /// specified offset, from the [CharacterData.data] string; when this
  /// method returns, [data] contains the shortened string.
  ///
  /// characterData.deleteData(offset, count)
  ///
  /// <span>Result: </span>A long string.
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.deleteData(1, 5);
  ///
  external Object deleteData(int offset, int count);

  ///  Replaces the specified amount of characters, starting at the
  /// specified offset, with the specified [DOMString]; when this
  /// method returns, [data] contains the modified string.
  ///
  /// characterData.replaceData(offset, count, data)
  ///
  /// <span>Result: </span>A long string.
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.replaceData(2, 4, "replaced");
  ///
  external Object replaceData(int offset, int count, String data);
}

/// The interface represents a text [node] in a DOM tree.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Text
///
///
///  To understand what a text node is, consider the following
/// document:
/// [<html class="e"><head><title>Aliens?</title></head>
///  <body>Why yes.
/// </body></html>
/// ]
///  In that document, there are three text nodes, with the following
/// contents:
///
///  "[Aliens?]" (the contents of the [title] element)
///   "[\n]" (after the [</head>] end tag, a newline followed by a
/// space)
///  "[Why yes.\n]" (the contents of the [body] element)
///
///  Each of those text nodes is an object that has the properties
/// and methods documented in this article.
@JS()
@staticInterop
class Text implements CharacterData, GeometryUtils, Slottable {
  external factory Text([String? data = '']);
}

extension PropsText on Text {
  /// Breaks the node into two nodes at a specified offset.
  ///
  /// newNode = textNode.splitText(offset)
  ///
  ///
  ///  In this example, the text of a <p> is split into two text nodes, and a
  ///  <u> is inserted between them.
  ///
  /// <p>foobar</p>
  ///
  /// const p = document.querySelector('p');
  ///
  /// // Get contents of <p> as a text node
  /// const foobar = p.firstChild;
  ///
  /// // Split 'foobar' into two text nodes, 'foo' and 'bar',
  /// // and save 'bar' as a const
  /// const bar = foobar.splitText(3);
  ///
  /// // Create a <u> element containing ' new content '
  /// const u = document.createElement('u');
  /// u.appendChild(document.createTextNode(' new content '));
  ///
  /// // Add <u> before 'bar'
  /// p.insertBefore(u, bar);
  ///
  /// // The result is: <p>foo<u> new content </u>bar</p>
  ///
  external Text splitText(int offset);

  ///  Returns a [DOMString] containing the text of all [Text] nodes
  /// logically adjacent to this [Node], concatenated in document
  /// order.
  ///
  external String get wholeText;
}

///
///  The interface represents a CDATA section
///   that can be used within XML to include extended portions of
/// unescaped text.
///   When inside a CDATA section, the symbols [<] and [&] don't need
/// escaping
///  as they normally do.
///
/// In XML, a CDATA section looks like:
/// [<![CDATA[ ... ]]>
/// ]
/// For example:
///  [<foo>Here is a CDATA section: <![CDATA[ < > & ]]> with all
/// kinds of unescaped text.</foo>
/// ]
///
///   The only sequence which is not allowed within a CDATA section
/// is the closing sequence
///  of a CDATA section itself, []]>].
///   *Note: CDATA sections should not be used within HTML they are
/// considered as comments and not displayed.
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Text
///
///
///
///
///
///    CDATASection
///
///
@JS()
@staticInterop
class CDATASection implements Text {
  external factory CDATASection();
}

///  The interface represents a processing instruction; that is, a
/// [Node] which embeds an instruction targeting a specific
/// application but that can be ignored by any other applications
/// which don't recognize the instruction.
///
///   Warning: nodes are only supported in XML documents, not in HTML
/// documents. In these, a process instruction will be considered as
/// a comment and be represented as a [Comment] object in the tree.
///
///  A processing instruction may be different than the XML
/// declaration.
///
///   Note: User-defined processing instructions cannot begin with
/// "[xml]", as [xml]-prefixed processing-instruction target names
/// are reserved by the XML specification for particular, standard
/// uses (see, for example, [<?xml-stylesheet ?>].
///
/// For example:
/// [<?xml version="1.0"?>
/// ]
/// is a processing instruction whose [target]is [xml].
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    ProcessingInstruction
///
///
@JS()
@staticInterop
class ProcessingInstruction implements CharacterData, LinkStyle {
  external factory ProcessingInstruction();
}

extension PropsProcessingInstruction on ProcessingInstruction {
  ///  A name identifying the application to which the instruction is
  /// targeted.
  ///
  external String get target;
}

///  The interface represents textual notations within markup;
/// although it is generally not visually shown, such comments are
/// available to be read in the source view.
///  Comments are represented in HTML and XML as content between
/// '[<!--]' and '[-->]'. In XML, like inside SVG or MathML markup,
/// the character sequence '[--]' cannot be used within a comment.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Comment
///
///
@JS()
@staticInterop
class Comment implements CharacterData {
  external factory Comment([String? data = '']);
}

///  The abstract interface is the base class upon which all DOM
/// range types are defined. A range is an object that indicates the
/// start and end points of a section of content within the document.
///  As an abstract interface, you will not directly instantiate an
/// object of type . Instead, you will use the [Range] or
/// [StaticRange] interfaces. To understand the difference between
/// those two interfaces, and how to choose which is appropriate for
/// your needs.
@JS()
@staticInterop
class AbstractRange {
  external factory AbstractRange();
}

extension PropsAbstractRange on AbstractRange {
  ///  The DOM [Node] in which the beginning of the range, as specified
  /// by the [startOffset] property, is located.
  ///
  external Node get startContainer;

  ///  An integer value indicating the offset, in characters, from the
  /// beginning of the node's contents to the last character of the
  /// contents referred to by the range object. This value must be less
  /// than the length of the node indicated in [startContainer].
  ///
  external int get startOffset;

  ///  The DOM [Node] in which the end of the range, as specified by
  /// the [endOffset] property, is located.
  ///
  external Node get endContainer;

  ///  An integer value indicating the offset, in characters, from the
  /// beginning of the node's contents to the beginning of the range
  /// represented by the range object. This value must be less than the
  /// length of the [endContainer] node.
  ///
  external int get endOffset;

  ///  A Boolean value which is [true] if the range is collapsed. A
  /// collapsed range is one whose start position and end position are
  /// the same, resulting in a zero-character-long range.
  ///
  external bool get collapsed;
}

@anonymous
@JS()
@staticInterop
class StaticRangeInit {
  external factory StaticRangeInit(
      {Node startContainer, int startOffset, Node endContainer, int endOffset});
}

extension PropsStaticRangeInit on StaticRangeInit {
  external Node get startContainer;
  external set startContainer(Node newValue);
  external int get startOffset;
  external set startOffset(int newValue);
  external Node get endContainer;
  external set endContainer(Node newValue);
  external int get endOffset;
  external set endOffset(int newValue);
}

///  The DOM interface extends [AbstractRange] to provide a method to
/// specify a range of content in the DOM whose contents don't update
/// to reflect changes which occur within the DOM tree.
///  This interface offers the same set of properties and methods as
/// [AbstractRange].
/// [AbstractRange] and are not available from web workers.
///
///
///
///    AbstractRange
///
///
///
///
///
///    StaticRange
///
///
@JS()
@staticInterop
class StaticRange implements AbstractRange {
  external factory StaticRange(StaticRangeInit init);
}

///  The interface represents a fragment of a document that can
/// contain nodes and parts of text nodes.
///  A range can be created by using the [Document.createRange()]
/// method. Range objects can also be retrieved by using the
/// [getRangeAt()] method of the [Selection] object or the
/// [caretRangeFromPoint()] method of the [Document] object.
/// There also is the [Range()] constructor available.
@JS()
@staticInterop
class Range implements AbstractRange {
  external static int get START_TO_START;
  external static int get START_TO_END;
  external static int get END_TO_END;
  external static int get END_TO_START;
  external factory Range();
}

extension PropsRange on Range {
  ///  Returns the deepest [Node] that contains the [startContainer]
  /// and [endContainer] nodes.
  ///
  external Node get commonAncestorContainer;

  /// Sets the start position of a [Range].
  ///
  /// range.setStart(startNode, startOffset);
  ///
  external Object setStart(Node node, int offset);

  /// Sets the end position of a [Range].
  ///
  /// range.setEnd(endNode, endOffset);
  ///
  /// const range = document.createRange();
  /// const endNode = document.getElementsByTagName('p').item(3);
  /// const endOffset = endNode.childNodes.length;
  /// range.setEnd(endNode, endOffset);
  ///
  ///   Note: setEnd() is commonly used in conjunction with
  ///   setStart() to fully configure a range.
  ///
  ///
  external Object setEnd(Node node, int offset);

  /// Sets the start position of a [Range] relative to another [Node].
  ///
  /// range.setStartBefore(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName("div").item(0);
  ///
  /// range.setStartBefore(referenceNode);
  ///
  external Object setStartBefore(Node node);

  /// Sets the start position of a [Range] relative to another [Node].
  ///
  /// range.setStartAfter(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName("div").item(0);
  ///
  /// range.setStartAfter(referenceNode);
  ///
  external Object setStartAfter(Node node);

  /// Sets the end position of a [Range] relative to another [Node].
  ///
  /// range.setEndBefore(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName("div").item(0);
  ///
  /// range.setEndBefore(referenceNode);
  ///
  external Object setEndBefore(Node node);

  /// Sets the end position of a [Range] relative to another [Node].
  ///
  /// range.setEndAfter(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName('div').item(0);
  ///
  /// range.setEndAfter(referenceNode);
  ///
  external Object setEndAfter(Node node);

  /// Collapses the [Range] to one of its boundary points.
  ///
  /// range.collapse(toStart);
  ///
  /// var range = document.createRange();
  ///
  /// referenceNode = document.getElementsByTagName("div").item(0);
  /// range.selectNode(referenceNode);
  /// range.collapse(true);
  ///
  external Object collapse([bool? toStart = false]);

  /// Sets the [Range] to contain the [Node] and its contents.
  ///
  /// range.selectNode(referenceNode);
  ///
  /// let range = document.createRange();
  /// let referenceNode = document.getElementsByTagName('div').item(0);
  ///
  /// range.selectNode(referenceNode);
  ///
  external Object selectNode(Node node);

  /// Sets the [Range] to contain the contents of a [Node].
  ///
  /// range.selectNodeContents(referenceNode);
  ///
  /// range = document.createRange();
  /// referenceNode = document.getElementsByTagName("div")[0];
  /// range.selectNodeContents(referenceNode);
  ///
  external Object selectNodeContents(Node node);

  ///  Compares the boundary points of the [Range] with another
  /// [Range].
  ///
  /// compare = range.compareBoundaryPoints(how, sourceRange);
  ///
  /// var range, sourceRange, compare;
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div")[0]);
  /// sourceRange = document.createRange();
  /// sourceRange.selectNode(document.getElementsByTagName("div")[1]);
  /// compare = range.compareBoundaryPoints(Range.START_TO_END, sourceRange);
  ///
  external int compareBoundaryPoints(int how, Range sourceRange);

  /// Removes the contents of a [Range] from the [Document].
  ///
  /// range.deleteContents()
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// range.deleteContents();
  ///
  external Object deleteContents();

  ///  Moves contents of a [Range] from the document tree into a
  /// [DocumentFragment].
  ///
  /// documentFragment = range.extractContents();
  ///
  external DocumentFragment extractContents();

  /// Returns a [DocumentFragment] copying the nodes of a [Range].
  ///
  /// documentFragment = range.cloneContents();
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// documentFragment = range.cloneContents();
  /// document.body.appendChild(documentFragment);
  ///
  external DocumentFragment cloneContents();

  /// Insert a [Node] at the start of a [Range].
  ///
  /// range.insertNode(newNode);
  ///
  /// range = document.createRange();
  /// newNode = document.createElement("p");
  /// newNode.appendChild(document.createTextNode("New Node Inserted Here"));
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// range.insertNode(newNode);
  ///
  external Object insertNode(Node node);

  /// Moves content of a [Range] into a new [Node].
  ///
  /// range.surroundContents(newParent);
  ///
  external Object surroundContents(Node newParent);

  ///  Returns a [Range] object with boundary points identical to the
  /// cloned [Range].
  ///
  /// clone = range.cloneRange();
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// clone = range.cloneRange();
  ///
  external Range cloneRange();

  /// Releases the [Range] from use to improve performance.
  ///
  /// range.detach();
  ///
  /// var range = document.createRange();
  ///
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// range.detach();
  ///
  external Object detach();

  ///  Returns a [boolean] indicating whether the given point is in the
  /// [Range].
  ///
  /// bool = range.isPointInRange( referenceNode, offset )
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// bool = range.isPointInRange(document.getElementsByTagName("p").item(0),1);
  ///
  @experimental
  external bool isPointInRange(Node node, int offset);

  ///  Returns -1, 0, or 1 indicating whether the point occurs before,
  /// inside, or after the [Range].
  ///
  /// returnValue = range.comparePoint(referenceNode, offset)
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName('div').item(0));
  /// returnValue = range.comparePoint(document.getElementsByTagName('p').item(0), 1);
  ///
  @experimental
  external int comparePoint(Node node, int offset);

  ///  Returns a [boolean] indicating whether the given node intersects
  /// the [Range].
  ///
  /// bool = range.intersectsNode( referenceNode )
  ///
  /// var range = document.createRange();
  ///
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// var bool = range.intersectsNode(document.getElementsByTagName("p").item(0));
  ///
  @experimental
  external bool intersectsNode(Node node);
  @JS('toString')
  external String mToString();
  external DOMRectList getClientRects();
  external DOMRect getBoundingClientRect();
  external DocumentFragment createContextualFragment(String fragment);
}

///
///  The interface
///   represents an iterator over the members of a list of the nodes
/// in a subtree of the
///  DOM. The nodes will be returned in document order.
///
@JS()
@staticInterop
class NodeIterator {
  external factory NodeIterator();
}

extension PropsNodeIterator on NodeIterator {
  ///
  ///     Returns a [Node] representing the root node as specified when
  /// the
  ///    [NodeIterator] was created.
  ///
  ///
  external Node get root;

  /// Returns the [Node] to which the iterator is anchored.
  ///
  @experimental
  external Node get referenceNode;

  ///
  ///    Returns a boolean flag that indicates whether the
  ///    [NodeIterator] is anchored before, the flag being [true],
  ///    or after, the flag being [false], the anchor node.
  ///
  ///
  @experimental
  external bool get pointerBeforeReferenceNode;

  ///
  ///    Returns an [unsigned long] being a bitmask made of constants
  ///    describing the types of [Node] that must to be presented.
  ///     Non-matching nodes are skipped, but their children may be
  /// included, if
  ///    relevant.
  ///
  ///   The possible values are:
  ///
  ///
  ///
  ///      Constant
  ///      Numerical value
  ///      Description
  ///
  ///
  ///
  ///
  ///      [NodeFilter.SHOW_ALL]
  ///      [4294967295] (that is the max value of [unsigned long])
  ///      Shows all nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ATTRIBUTE]
  ///
  ///
  ///      [2]
  ///       Shows attribute [Attr] nodes. This is meaningful only when
  /// creating a [NodeIterator] with an [Attr] node as its root; in
  /// this case, it means that the attribute node will appear in the
  /// first position of the iteration or traversal. Since attributes
  /// are never children of other nodes, they do not appear when
  /// traversing over the document tree.
  ///
  ///
  ///      [NodeFilter.SHOW_CDATA_SECTION]
  ///
  ///
  ///      [8]
  ///      Shows [CDATASection] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_COMMENT]
  ///      [128]
  ///      Shows [Comment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT]
  ///      [256]
  ///      Shows [Document] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_FRAGMENT]
  ///      [1024]
  ///      Shows [DocumentFragment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_TYPE]
  ///      [512]
  ///      Shows [DocumentType] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ELEMENT]
  ///      [1]
  ///      Shows [Element] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY]
  ///
  ///
  ///      [32]
  ///      Legacy, no more used.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY_REFERENCE]
  ///
  ///
  ///      [16]
  ///      Legacy, no more used.
  ///
  ///
  ///      [NodeFilter.SHOW_NOTATION]
  ///
  ///
  ///      [2048]
  ///      Legacy, no more used.
  ///
  ///
  ///      [NodeFilter.SHOW_PROCESSING_INSTRUCTION]
  ///      [64]
  ///      Shows [ProcessingInstruction] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_TEXT]
  ///      [4]
  ///      Shows [Text] nodes.
  ///
  ///
  ///
  ///
  external int get whatToShow;

  /// Returns a [NodeFilter] used to select the relevant nodes.
  ///
  external NodeFilter? get filter;

  ///
  ///    Returns the next [Node] in the document, or [null] if
  ///    there are none.
  ///
  ///
  /// node = nodeIterator.nextNode();
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///   false // this optional argument is not used any more
  /// );
  /// currentNode = nodeIterator.nextNode(); // returns the next node
  ///
  external Node? nextNode();

  ///
  ///    Returns the previous [Node] in the document, or [null] if
  ///    there are none.
  ///
  ///
  /// node = nodeIterator.previousNode();
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///   false // this optional argument is not used any more
  /// );
  /// currentNode = nodeIterator.nextNode(); // returns the next node
  /// previousNode = nodeIterator.previousNode(); // same result, since we backtracked to the previous node
  ///
  external Node? previousNode();

  ///
  ///     This operation is a no-op. It doesn't do anything. Previously
  /// it was telling the
  ///     engine that the [NodeIterator] was no more used, but this is
  /// now
  ///    useless.
  ///
  ///
  /// nodeIterator.detach();
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///   false
  /// );
  /// nodeIterator.detach(); // detaches the iterator
  ///
  /// nodeIterator.nextNode(); // throws an INVALID_STATE_ERR exception
  ///
  @deprecated
  external Object detach();
}

///  The object represents the nodes of a document subtree and a
/// position within them.
/// A can be created using the [Document.createTreeWalker()] method.
@JS()
@staticInterop
class TreeWalker {
  external factory TreeWalker();
}

extension PropsTreeWalker on TreeWalker {
  ///  Returns a [Node] representing the root node as specified when
  /// the [TreeWalker] was created.
  ///
  external Node get root;

  ///  Returns an [unsigned long] being a bitmask made of constants
  /// describing the types of [Node] that must be presented.
  /// Non-matching nodes are skipped, but their children may be
  /// included, if relevant. The possible values are:
  ///
  ///
  ///
  ///      Constant
  ///      Numerical value
  ///      Description
  ///
  ///
  ///
  ///
  ///      [NodeFilter.SHOW_ALL]
  ///      [4294967295] (that is the max value of [unsigned long])
  ///      Shows all nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ATTRIBUTE]
  ///
  ///
  ///      [2]
  ///       Shows attribute [Attr] nodes. This is meaningful only when
  /// creating a [TreeWalker] with an [Attr] node as its root. In this
  /// case, it means that the attribute node will appear in the first
  /// position of the iteration or traversal. Since attributes are
  /// never children of other nodes, they do not appear when traversing
  /// over the document tree.
  ///
  ///
  ///      [NodeFilter.SHOW_CDATA_SECTION]
  ///
  ///
  ///      [8]
  ///      Shows [CDATASection] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_COMMENT]
  ///      [128]
  ///      Shows [Comment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT]
  ///      [256]
  ///      Shows [Document] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_FRAGMENT]
  ///      [1024]
  ///      Shows [DocumentFragment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_TYPE]
  ///      [512]
  ///      Shows [DocumentType] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ELEMENT]
  ///      [1]
  ///      Shows [Element] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY]
  ///
  ///
  ///      [32]
  ///      Legacy, no more usable.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY_REFERENCE]
  ///
  ///
  ///      [16]
  ///      Legacy, no more usable.
  ///
  ///
  ///      [NodeFilter.SHOW_NOTATION]
  ///
  ///
  ///      [2048]
  ///      Legacy, no more usable.
  ///
  ///
  ///      [NodeFilter.SHOW_PROCESSING_INSTRUCTION]
  ///      [64]
  ///      Shows [ProcessingInstruction] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_TEXT]
  ///      [4]
  ///      Shows [Text] nodes.
  ///
  ///
  ///
  ///
  external int get whatToShow;

  /// Returns a [NodeFilter] used to select the relevant nodes.
  ///
  external NodeFilter? get filter;

  ///  Is the [Node] on which the [TreeWalker] is currently pointing
  /// at.
  ///
  external Node get currentNode;
  external set currentNode(Node newValue);
  external Node? parentNode();
  external Node? firstChild();
  external Node? lastChild();
  external Node? previousSibling();
  external Node? nextSibling();
  external Node? previousNode();
  external Node? nextNode();
}

///  A interface represents an object used to filter the nodes in a
/// [NodeIterator] or [TreeWalker]. A knows nothing about the
/// document or traversing nodes; it only knows how to evaluate a
/// single node against the provided filter.
///
///   Note: The browser doesn't provide any object implementing this
/// interface. It is the user who is expected to write one, tailoring
/// the [acceptNode()] method to its needs, and using it with some
/// [TreeWalker] or [NodeIterator] objects.
///
@JS()
@staticInterop
class NodeFilter {
  external static int get FILTER_ACCEPT;
  external static int get FILTER_REJECT;
  external static int get FILTER_SKIP;
  external static int get SHOW_ALL;
  external static int get SHOW_ELEMENT;
  external static int get SHOW_ATTRIBUTE;
  external static int get SHOW_TEXT;
  external static int get SHOW_CDATA_SECTION;
  external static int get SHOW_ENTITY_REFERENCE;
  external static int get SHOW_ENTITY;
  external static int get SHOW_PROCESSING_INSTRUCTION;
  external static int get SHOW_COMMENT;
  external static int get SHOW_DOCUMENT;
  external static int get SHOW_DOCUMENT_TYPE;
  external static int get SHOW_DOCUMENT_FRAGMENT;
  external static int get SHOW_NOTATION;
  external factory NodeFilter();
}

extension PropsNodeFilter on NodeFilter {
  ///  Returns an [unsigned short] that will be used to tell if a given
  /// [Node] must be accepted or not by the [NodeIterator] or
  /// [TreeWalker] iteration algorithm.
  ///    This method is expected to be written by the user of a
  /// [NodeFilter]. Possible return values are:
  ///
  ///
  ///
  ///      Constant
  ///      Description
  ///
  ///
  ///
  ///
  ///      [FILTER_ACCEPT]
  ///
  ///       Value returned by the
  ///       [NodeFilter.acceptNode()] method when a node
  ///       should be accepted.
  ///
  ///
  ///
  ///      [FILTER_REJECT]
  ///
  ///
  ///        Value to be returned by the
  ///        [NodeFilter.acceptNode()] method when a
  ///        node should be rejected. For [TreeWalker], child
  ///        nodes are also rejected.
  ///
  ///
  ///        For [NodeIterator], this flag is synonymous
  ///        with [FILTER_SKIP].
  ///
  ///
  ///
  ///
  ///      [FILTER_SKIP]
  ///
  ///
  ///        Value to be returned by
  ///        [NodeFilter.acceptNode()] for nodes to be
  ///        skipped by the [NodeIterator] or
  ///        [TreeWalker] object.
  ///
  ///
  ///         The children of skipped nodes are still considered. This
  /// is treated as
  ///        "skip this node but not its children".
  ///
  ///
  ///
  ///
  ///
  ///
  /// result = nodeFilter.acceptNode(node)
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///  // Node to use as root
  ///  document.getElementById('someId'),
  ///
  ///  // Only consider nodes that are text nodes (nodeType 3)
  ///  NodeFilter.SHOW_TEXT,
  ///
  ///  // Object containing the function to use for the acceptNode method
  ///  // of the NodeFilter
  ///   { acceptNode: function(node) {
  ///    // Logic to determine whether to accept, reject or skip node
  ///    // In this case, only accept nodes that have content
  ///    // other than whitespace
  ///    if ( ! /^\s*$/.test(node.data) ) {
  ///     return NodeFilter.FILTER_ACCEPT;
  ///    }
  ///   }
  ///  },
  ///  false
  /// );
  ///
  /// // Show the content of every non-empty text node that is a child of root
  /// var node;
  ///
  /// while ((node = nodeIterator.nextNode())) {
  ///  alert(node.data);
  /// }
  ///
  external int acceptNode(Node node);
}

///  The interface represents a set of space-separated tokens. Such a
/// set is returned by [Element.classList] or
/// [HTMLLinkElement.relList], and many others.
///  A is indexed beginning with [0] as with JavaScript [Array]
/// objects. is always case-sensitive.
@JS()
@staticInterop
class DOMTokenList {
  external factory DOMTokenList();
}

extension PropsDOMTokenList on DOMTokenList {
  ///  Is an [integer] representing the number of objects stored in the
  /// object.
  ///
  external int get length;

  ///  Returns the item in the list by its index, or [undefined] if the
  /// index is greater than or equal to the list's [length].
  ///
  /// tokenList.item(index)
  ///
  external String? item(int index);

  ///  Returns [true] if the list contains the given token, otherwise
  /// [false].
  ///
  /// contains(token);
  ///
  external bool contains(String token);

  /// Adds the specified tokens to the list.
  ///
  /// add(token0);
  /// add(token0, token1);
  /// add(token0, token1, /* ... ,*/ tokenN)
  ///
  external Object add([String tokens]);

  /// Removes the specified tokens from the list.
  ///
  /// remove(token);
  /// remove(token, token);
  /// remove(token, token, token);
  /// ...
  ///
  external Object remove([String tokens]);

  ///  Removes the token from the list if it exists, or adds it to the
  /// list if it doesn't. Returns a boolean indicating whether the
  /// token is in the list after the operation.
  ///
  /// toggle(token);
  /// toggle(token, force);
  ///
  external bool toggle(String token, [bool? force]);

  /// Replaces the token with another one.
  ///
  /// replace(oldToken, newToken);
  ///
  external bool replace(String token, String newToken);

  ///  Returns [true] if the given token is in the associated
  /// attribute's supported tokens.
  ///
  /// supports(token);
  ///
  /// const iframe = document.getElementById('display');
  ///
  /// if (iframe.sandbox.supports('an-upcoming-feature')) {
  ///  // support code for mystery future feature
  /// } else {
  ///  // fallback code
  /// }
  ///
  /// if (iframe.sandbox.supports('allow-scripts')) {
  ///  // instruct frame to run JavaScript
  ///  //
  ///  // (NOTE: This feature is well-supported; this is just an example!)
  ///  //
  /// }
  ///
  external bool supports(String token);

  ///  A stringifier property that returns the value of the list as a
  /// string.
  ///
  external String get value;
  external set value(String newValue);
}

///  The interface represents the results generated by evaluating an
/// XPath expression within the context of a given node.
///  Since XPath expressions can result in a variety of result types,
/// this interface makes it possible to determine and handle the type
/// and value of the result.
@JS()
@staticInterop
class XPathResult {
  external static int get ANY_TYPE;
  external static int get NUMBER_TYPE;
  external static int get STRING_TYPE;
  external static int get BOOLEAN_TYPE;
  external static int get UNORDERED_NODE_ITERATOR_TYPE;
  external static int get ORDERED_NODE_ITERATOR_TYPE;
  external static int get UNORDERED_NODE_SNAPSHOT_TYPE;
  external static int get ORDERED_NODE_SNAPSHOT_TYPE;
  external static int get ANY_UNORDERED_NODE_TYPE;
  external static int get FIRST_ORDERED_NODE_TYPE;
  external factory XPathResult();
}

extension PropsXPathResult on XPathResult {
  ///  A [number] code representing the type of the result, as defined
  /// by the type constants.
  ///
  external int get resultType;

  ///  A [number] representing the value of the result if [resultType]
  /// is [NUMBER_TYPE].
  ///
  external /* double | NaN */ dynamic get numberValue;

  ///  A [string] representing the value of the result if [resultType]
  /// is [STRING_TYPE].
  ///
  external String get stringValue;

  ///  A [boolean] representing the value of the result if [resultType]
  /// is [BOOLEAN_TYPE].
  ///
  external bool get booleanValue;

  ///  A [Node] representing the value of the single node result, which
  /// may be [null].
  ///
  external Node? get singleNodeValue;

  ///  Signifies that the iterator has become invalid. It is [true] if
  /// [resultType] is [UNORDERED_NODE_ITERATOR_TYPE] or
  /// [ORDERED_NODE_ITERATOR_TYPE] and the document has been modified
  /// since this result was returned.
  ///
  external bool get invalidIteratorState;

  /// The number of nodes in the result snapshot.
  ///
  external int get snapshotLength;

  ///  If the result is a node set, this method iterates over it and
  /// returns the next node from it or [null] if there are no more
  /// nodes.
  ///
  /// var node = result.iterateNext();
  ///
  /// The following example shows the use of the iterateNext() method.
  /// <div>XPath example</div>
  /// <div>Tag names of the matched nodes: <output></output></div>
  ///
  /// ```
  ///
  /// var xpath = "//div";
  /// var result = document.evaluate(xpath, document, null, XPathResult.ANY_TYPE, null);
  /// var node = null;
  /// var tagNames = [];
  /// while(node = result.iterateNext()) {
  ///  tagNames.push(node.localName);
  /// }
  /// document.querySelector("output").textContent = tagNames.join(", ");
  ///
  /// ```
  ///
  external Node? iterateNext();

  ///  Returns an item of the snapshot collection or [null] in case the
  /// index is not within the range of nodes. Unlike the iterator
  /// result, the snapshot does not become invalid, but may not
  /// correspond to the current document if it is mutated.
  ///
  /// var node = result.snapshotItem(i);
  ///
  /// The following example shows the use of the snapshotItem() method.
  /// <div>XPath example</div>
  /// <div>Tag names of the matched nodes: <output></output></div>
  ///
  /// ```
  ///
  /// var xpath = "//div";
  /// var result = document.evaluate(xpath, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
  /// var node = null;
  /// var tagNames = [];
  /// for(var i = 0; i < result.snapshotLength; i++) {
  ///  var node = result.snapshotItem(i);
  ///  tagNames.push(node.localName);
  /// }
  /// document.querySelector("output").textContent = tagNames.join(", ");
  ///
  /// ```
  ///
  external Node? snapshotItem(int index);
}

///  This interface is a compiled XPath expression that can be
/// evaluated on a document or specific node to return information
/// from its DOM tree.
///  This is useful when an expression will be reused in an
/// application, because it is just compiled once and all namespace
/// prefixes which occur within the expression are preresolved.
///  Objects of this type are created by calling
/// [XPathEvaluator.createExpression()].
@JS()
@staticInterop
class XPathExpression {
  external factory XPathExpression();
}

extension PropsXPathExpression on XPathExpression {
  /// Evaluates the XPath expression on the given node or document.
  ///
  /// XPathResult node.evaluate(contextNode, type, result);
  ///
  /// The following example shows the use of the evaluate() method.
  /// <div>XPath example</div>
  /// <div>Number of &lt;div&gt;s: <output></output></div>
  ///
  /// ```
  ///
  /// var xpath = "//div";
  /// var evaluator = new XPathEvaluator();
  /// var expression = evaluator.createExpression("//div");
  /// var result = expression.evaluate(document, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
  /// document.querySelector("output").textContent = result.snapshotLength;
  ///
  /// ```
  ///
  external XPathResult evaluate(Node contextNode,
      [int? type = 0, XPathResult? result]);
}

///  The interface permits prefix strings in an XPath expression to
/// be properly bound to namespace URI strings.
///  The [XPathEvaluator] interface can construct an implementation
/// of from a node, or the interface may be implemented by any
/// application.
@JS()
@staticInterop
class XPathNSResolver {
  external factory XPathNSResolver();
}

extension PropsXPathNSResolver on XPathNSResolver {
  ///  Looks up the namespace URI associated to the given namespace
  /// prefix.
  ///
  /// DOMString XPathNSResolver.lookupNamespaceURI(prefix);
  ///
  external String? lookupNamespaceURI(String? prefix);
}

@JS()
@staticInterop
class XPathEvaluatorBase {
  external factory XPathEvaluatorBase();
}

extension PropsXPathEvaluatorBase on XPathEvaluatorBase {
  external XPathExpression createExpression(String expression,
      [XPathNSResolver? resolver]);
  external XPathNSResolver createNSResolver(Node nodeResolver);
  external XPathResult evaluate(String expression, Node contextNode,
      [XPathNSResolver? resolver, int? type = 0, XPathResult? result]);
}

/// The interface allows to compile and evaluate XPath expressions.
/// It is implemented by the [Document] interface.
@JS()
@staticInterop
class XPathEvaluator implements XPathEvaluatorBase {
  external factory XPathEvaluator();
}

///  Non-standard: This feature is non-standard and is not on a
/// standards track. Do not use it on production sites facing the
/// Web: it will not work for every user. There may also be large
/// incompatibilities between implementations and the behavior may
/// change in the future.Experimental: This is an experimental
/// technologyCheck the Browser compatibility table carefully before
/// using this in production.
///
///   An applies an XSLT stylesheet transformation to an XML document
/// to
///   produce a new XML document as output. It has methods to load
/// the XSLT stylesheet, to
///  manipulate [<xsl:param>] parameter values, and to apply the
///  transformation to documents.
///
@JS()
@staticInterop
class XSLTProcessor {
  external factory XSLTProcessor();
}

extension PropsXSLTProcessor on XSLTProcessor {
  ///
  ///     Imports the XSLT stylesheet. If the given node is a document
  /// node, you can pass in a
  ///    full XSL Transform or a literal result element
  /// transform; otherwise, it must be an [<xsl:stylesheet>] or
  ///    [<xsl:transform>] element.
  ///
  ///
  external Object importStylesheet(Node style);
  external DocumentFragment transformToFragment(Node source, Document output);
  external Document transformToDocument(Node source);

  ///
  ///     Sets a parameter in the XSLT stylesheet that was imported.
  /// (Sets the value of an
  ///    [<xsl:param>].) A null value for [namespaceURI] is treated
  ///    the same as an empty string.
  ///
  ///
  external Object setParameter(
      String namespaceURI, String localName, dynamic value);

  ///
  ///     Gets the value of a parameter from the XSLT stylesheet. A
  /// null value for
  ///    [namespaceURI] is treated the same as an empty string.
  ///
  ///
  external dynamic getParameter(String namespaceURI, String localName);

  ///
  ///     Removes the parameter if it was previously set. This will
  /// make the
  ///     [XSLTProcessor] use the default value for the parameter as
  /// specified in the
  ///     stylesheet. A null value for [namespaceURI] is treated the
  /// same as an empty
  ///    string.
  ///
  ///
  external Object removeParameter(String namespaceURI, String localName);

  ///
  ///    Removes all set parameters from the [XSLTProcessor]. The
  ///     [XSLTProcessor] will then use the defaults specified in the
  /// XSLT
  ///    stylesheet.
  ///
  ///
  external Object clearParameters();

  /// Removes all parameters and stylesheets from the [XSLTProcessor].
  ///
  external Object reset();
}
