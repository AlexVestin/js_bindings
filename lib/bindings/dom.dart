/// DOM Standard
///
/// https://dom.spec.whatwg.org/
@JS('window')
@staticInterop
library dom;

import 'dart:js_util' as js_util;
import 'package:js/js.dart';
import 'package:meta/meta.dart';

import 'callbacks.dart';
import '../manual.dart';
import 'all_bindings.dart';
/* deps: cssom_view_1
css_font_loading_3
dom
html
d_o_m_parsing
web_animations_1
wai_aria_1_2
css_regions_1
cssom_1
hr_time_3
page_visibility_2
css_typed_om_1
selection_api
geometry_1
fullscreen
css_pseudo_4
svg11
scroll_to_text_fragment
floc
permissions_policy_1
css_nav_1
font_metrics_api_1 */

/// The interface represents an event which takes place in the DOM.
///  An event can be triggered by the user action e.g. clicking the
/// mouse button or tapping keyboard, or generated by APIs to
/// represent the progress of an asynchronous task. It can also be
/// triggered programmatically, such as by calling the
/// [HTMLElement.click()] method of an element, or by defining the
/// event, then sending it to a specified target using
/// [EventTarget.dispatchEvent()].
///  There are many types of events, some of which use other
/// interfaces based on the main interface. itself contains the
/// properties and methods which are common to all events.
///  Many DOM elements can be set up to accept (or "listen" for)
/// these events, and execute code in response to process (or
/// "handle") them. Event-handlers are usually connected (or
/// "attached") to various HTML elements (such as [<button>],
/// [<div>], [<span>], etc.) using [EventTarget.addEventListener()],
/// and this generally replaces using the old HTML event handler
/// attributes. Further, when properly added, such handlers can also
/// be disconnected if needed using [removeEventListener()].
///
///   Note: One element can have several such handlers, even for the
/// exact same event—particularly if separate, independent code
/// modules attach them, each for its own independent purposes. (For
/// example, a webpage with an advertising-module and
/// statistics-module both monitoring video-watching.)
///
///  When there are many nested elements, each with its own
/// handler(s), event processing can become very
/// complicated—especially where a parent element receives the very
/// same event as its child elements because "spatially" they overlap
/// so the event technically occurs in both, and the processing order
/// of such events depends on the Event bubbling and capture settings
/// of each handler triggered.
@JS()
@staticInterop
class Event {
  external Event(String type, [EventInit? eventInitDict]);
  external static int get NONE;
  external static int get CAPTURING_PHASE;
  external static int get AT_TARGET;
  external static int get BUBBLING_PHASE;
}

extension PropsEvent on Event {
  /// The case-insensitive name identifying the type of the event.
  ///
  String get type => js_util.getProperty(this, 'type');

  ///  A reference to the object to which the event was originally
  /// dispatched.
  ///
  EventTarget? get target => js_util.getProperty(this, 'target');
  EventTarget? get srcElement => js_util.getProperty(this, 'srcElement');

  ///  A reference to the currently registered target for the event.
  /// This is the object to which the event is currently slated to be
  /// sent. It's possible this has been changed along the way through
  /// retargeting.
  ///
  EventTarget? get currentTarget => js_util.getProperty(this, 'currentTarget');

  ///  Returns the event's path (an array of objects on which listeners
  /// will be invoked). This does not include nodes in shadow trees if
  /// the shadow root was created with its [ShadowRoot.mode] closed.
  ///
  /// var composed = Event.composedPath();
  ///
  Iterable<EventTarget> composedPath() =>
      js_util.callMethod(this, 'composedPath', []);

  ///  Indicates which phase of the event flow is being processed. It
  /// is one of the following numbers: [NONE], [CAPTURING_PHASE],
  /// [AT_TARGET], [BUBBLING_PHASE].
  ///
  int get eventPhase => js_util.getProperty(this, 'eventPhase');

  /// Stops the propagation of events further along in the DOM.
  ///
  /// event.stopPropagation();
  ///
  Object stopPropagation() => js_util.callMethod(this, 'stopPropagation', []);

  bool get cancelBubble => js_util.getProperty(this, 'cancelBubble');
  set cancelBubble(bool newValue) {
    js_util.setProperty(this, 'cancelBubble', newValue);
  }

  ///  For this particular event, prevent all other listeners from
  /// being called. This includes listeners attached to the same
  /// element as well as those attached to elements that will be
  /// traversed later (during the capture phase, for instance).
  ///
  /// event.stopImmediatePropagation();
  ///
  Object stopImmediatePropagation() =>
      js_util.callMethod(this, 'stopImmediatePropagation', []);

  ///  A boolean value indicating whether or not the event bubbles up
  /// through the DOM.
  ///
  bool get bubbles => js_util.getProperty(this, 'bubbles');

  /// A boolean value indicating whether the event is cancelable.
  ///
  bool get cancelable => js_util.getProperty(this, 'cancelable');
  dynamic get returnValue => js_util.getProperty(this, 'returnValue');
  set returnValue(dynamic newValue) {
    js_util.setProperty(this, 'returnValue', newValue);
  }

  /// Cancels the event (if it is cancelable).
  ///
  /// event.preventDefault();
  ///
  Object preventDefault() => js_util.callMethod(this, 'preventDefault', []);

  ///  Indicates whether or not the call to [event.preventDefault()]
  /// canceled the event.
  ///
  bool get defaultPrevented => js_util.getProperty(this, 'defaultPrevented');

  ///  A boolean indicating whether or not the event can bubble across
  /// the boundary between the shadow DOM and the regular DOM.
  ///
  bool get composed => js_util.getProperty(this, 'composed');

  ///  Indicates whether or not the event was initiated by the browser
  /// (after a user click, for instance) or by a script (using an event
  /// creation method, for example).
  ///
  bool get isTrusted => js_util.getProperty(this, 'isTrusted');

  ///  The time at which the event was created (in milliseconds). By
  /// specification, this value is time since epoch—but in reality,
  /// browsers' definitions vary. In addition, work is underway to
  /// change this to be a [DOMHighResTimeStamp] instead.
  ///
  double get timeStamp => js_util.getProperty(this, 'timeStamp');
  Object initEvent(String type,
          [bool? bubbles = false, bool? cancelable = false]) =>
      js_util.callMethod(this, 'initEvent', [type, bubbles, cancelable]);
}

@anonymous
@JS()
@staticInterop
class EventInit {
  external factory EventInit(
      {bool bubbles = false, bool? cancelable = false, bool? composed = false});
}

extension PropsEventInit on EventInit {
  bool get bubbles => js_util.getProperty(this, 'bubbles');
  set bubbles(bool newValue) {
    js_util.setProperty(this, 'bubbles', newValue);
  }

  bool get cancelable => js_util.getProperty(this, 'cancelable');
  set cancelable(bool newValue) {
    js_util.setProperty(this, 'cancelable', newValue);
  }

  bool get composed => js_util.getProperty(this, 'composed');
  set composed(bool newValue) {
    js_util.setProperty(this, 'composed', newValue);
  }
}

///  The interface represents events initialized by an application
/// for any purpose.
///  Note: This feature is available in Web Workers
///
@JS()
@staticInterop
class CustomEvent implements Event {
  external CustomEvent(String type, [CustomEventInit? eventInitDict]);
}

extension PropsCustomEvent on CustomEvent {
  /// Returns any data passed when initializing the event.
  ///
  dynamic get detail => js_util.getProperty(this, 'detail');

  ///  Initializes a [CustomEvent] object. If the event has already
  /// being dispatched, this method does nothing.
  ///
  /// event.initCustomEvent(type, canBubble, cancelable, detail);
  ///
  @deprecated
  Object initCustomEvent(String type,
          [bool? bubbles = false, bool? cancelable = false, dynamic detail]) =>
      js_util.callMethod(
          this, 'initCustomEvent', [type, bubbles, cancelable, detail]);
}

@anonymous
@JS()
@staticInterop
class CustomEventInit implements EventInit {
  external factory CustomEventInit({dynamic detail});
}

extension PropsCustomEventInit on CustomEventInit {
  dynamic get detail => js_util.getProperty(this, 'detail');
  set detail(dynamic newValue) {
    js_util.setProperty(this, 'detail', newValue);
  }
}

///
///   The interface is implemented by objects that can receive events
/// and may have listeners for them.
///   In other words, any target of events implements the three
/// methods associated with this interface.
///   [Element], and its children, as well as [Document] and
/// [Window], are the most common event targets,
///  but other objects can be event targets, too.
///   For example [XMLHttpRequest], [AudioNode], and [AudioContext]
/// are also event targets.
///
///  Many event targets (including elements, documents, and windows)
/// also support setting event handlers via [onevent] properties and
/// attributes.
@JS()
@staticInterop
class EventTarget {
  external EventTarget();
}

extension PropsEventTarget on EventTarget {
  ///  Registers an event handler of a specific event type on the
  /// [EventTarget].
  ///
  /// addEventListener(type, listener);
  /// addEventListener(type, listener, options);
  /// addEventListener(type, listener, useCapture);
  ///
  Object addEventListener(String type, EventListener? callback,
          [dynamic options]) =>
      js_util.callMethod(this, 'addEventListener',
          [type, callback == null ? null : allowInterop(callback), options]);

  /// Removes an event listener from the [EventTarget].
  ///
  /// removeEventListener(type, listener);
  /// removeEventListener(type, listener, options);
  /// removeEventListener(type, listener, useCapture);
  ///
  ///
  ///  This example shows how to add a mouseover-based event listener that
  ///  removes a click-based event listener.
  ///
  /// const body = document.querySelector('body')
  /// const clickTarget = document.getElementById('click-target')
  /// const mouseOverTarget = document.getElementById('mouse-over-target')
  ///
  /// let toggle = false;
  /// function makeBackgroundYellow() {
  ///  if (toggle) {
  ///   body.style.backgroundColor = 'white';
  ///  } else {
  ///   body.style.backgroundColor = 'yellow';
  ///  }
  ///
  ///  toggle = !toggle;
  /// }
  ///
  /// clickTarget.addEventListener('click',
  ///  makeBackgroundYellow,
  ///  false
  /// );
  ///
  /// mouseOverTarget.addEventListener('mouseover', function () {
  ///  clickTarget.removeEventListener('click',
  ///   makeBackgroundYellow,
  ///   false
  ///  );
  /// });
  ///
  Object removeEventListener(String type, EventListener? callback,
          [dynamic options]) =>
      js_util.callMethod(this, 'removeEventListener',
          [type, callback == null ? null : allowInterop(callback), options]);

  /// Dispatches an event to this [EventTarget].
  ///
  /// dispatchEvent(event)
  ///
  /// See Creating and triggering events.
  bool dispatchEvent(Event event) =>
      js_util.callMethod(this, 'dispatchEvent', [event]);
}

@anonymous
@JS()
@staticInterop
class EventListenerOptions {
  external factory EventListenerOptions({bool capture = false});
}

extension PropsEventListenerOptions on EventListenerOptions {
  bool get capture => js_util.getProperty(this, 'capture');
  set capture(bool newValue) {
    js_util.setProperty(this, 'capture', newValue);
  }
}

@anonymous
@JS()
@staticInterop
class AddEventListenerOptions implements EventListenerOptions {
  external factory AddEventListenerOptions(
      {bool passive = false, bool? once = false, AbortSignal? signal});
}

extension PropsAddEventListenerOptions on AddEventListenerOptions {
  bool get passive => js_util.getProperty(this, 'passive');
  set passive(bool newValue) {
    js_util.setProperty(this, 'passive', newValue);
  }

  bool get once => js_util.getProperty(this, 'once');
  set once(bool newValue) {
    js_util.setProperty(this, 'once', newValue);
  }

  AbortSignal get signal => js_util.getProperty(this, 'signal');
  set signal(AbortSignal newValue) {
    js_util.setProperty(this, 'signal', newValue);
  }
}

///  The interface represents a controller object that allows you to
/// abort one or more Web requests as and when desired.
///  You can create a new object using the [AbortController()]
/// constructor. Communicating with a DOM request is done using an
/// [AbortSignal] object.
@experimental
@JS()
@staticInterop
class AbortController {
  external AbortController();
}

extension PropsAbortController on AbortController {
  ///  Returns an [AbortSignal] object instance, which can be used to
  /// communicate with, or to abort, a DOM request.
  ///
  AbortSignal get signal => js_util.getProperty(this, 'signal');

  ///  Aborts a DOM request before it has completed. This is able to
  /// abort fetch requests, consumption of any response bodies, and
  /// streams.
  ///
  /// abort()
  /// abort(reason)
  ///
  Object abort() => js_util.callMethod(this, 'abort', []);
}

///  The interface represents a signal object that allows you to
/// communicate with a DOM request (such as a fetch request) and
/// abort it if required via an [AbortController] object.
@experimental
@JS()
@staticInterop
class AbortSignal implements EventTarget {
  external AbortSignal();
}

extension PropsAbortSignal on AbortSignal {
  static AbortSignal abort() => js_util.callMethod(AbortSignal, 'abort', []);

  ///  A Boolean that indicates whether the request(s) the signal is
  /// communicating with is/are aborted ([true]) or not ([false]).
  ///
  bool get aborted => js_util.getProperty(this, 'aborted');
  EventHandlerNonNull? get onabort => js_util.getProperty(this, 'onabort');
  set onabort(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onabort', newValue);
  }
}

@JS()
@staticInterop
class NonElementParentNode {
  external NonElementParentNode();
}

extension PropsNonElementParentNode on NonElementParentNode {
  Element? getElementById(String elementId) =>
      js_util.callMethod(this, 'getElementById', [elementId]);
}

@JS()
@staticInterop
class DocumentOrShadowRoot {
  external DocumentOrShadowRoot();
}

extension PropsDocumentOrShadowRoot on DocumentOrShadowRoot {
  Iterable<Animation> getAnimations() =>
      js_util.callMethod(this, 'getAnimations', []);

  Element? get pointerLockElement =>
      js_util.getProperty(this, 'pointerLockElement');
  Element? get fullscreenElement =>
      js_util.getProperty(this, 'fullscreenElement');
  Iterable<CSSStyleSheet> get adoptedStyleSheets =>
      js_util.getProperty(this, 'adoptedStyleSheets');
  set adoptedStyleSheets(Iterable<CSSStyleSheet> newValue) {
    js_util.setProperty(this, 'adoptedStyleSheets', newValue);
  }

  Element? get pictureInPictureElement =>
      js_util.getProperty(this, 'pictureInPictureElement');
  Element? get activeElement => js_util.getProperty(this, 'activeElement');
  StyleSheetList get styleSheets => js_util.getProperty(this, 'styleSheets');
}

@JS()
@staticInterop
class ParentNode {
  external ParentNode();
}

extension PropsParentNode on ParentNode {
  HTMLCollection get children => js_util.getProperty(this, 'children');
  Element? get firstElementChild =>
      js_util.getProperty(this, 'firstElementChild');
  Element? get lastElementChild =>
      js_util.getProperty(this, 'lastElementChild');
  int get childElementCount => js_util.getProperty(this, 'childElementCount');
  Object prepend([dynamic nodes]) =>
      js_util.callMethod(this, 'prepend', [nodes]);

  Object append([dynamic nodes]) => js_util.callMethod(this, 'append', [nodes]);

  Object replaceChildren([dynamic nodes]) =>
      js_util.callMethod(this, 'replaceChildren', [nodes]);

  Element? querySelector(String selectors) =>
      js_util.callMethod(this, 'querySelector', [selectors]);

  NodeList querySelectorAll(String selectors) =>
      js_util.callMethod(this, 'querySelectorAll', [selectors]);
}

@JS()
@staticInterop
class NonDocumentTypeChildNode {
  external NonDocumentTypeChildNode();
}

extension PropsNonDocumentTypeChildNode on NonDocumentTypeChildNode {
  Element? get previousElementSibling =>
      js_util.getProperty(this, 'previousElementSibling');
  Element? get nextElementSibling =>
      js_util.getProperty(this, 'nextElementSibling');
}

@JS()
@staticInterop
class ChildNode {
  external ChildNode();
}

extension PropsChildNode on ChildNode {
  Object before([dynamic nodes]) => js_util.callMethod(this, 'before', [nodes]);

  Object after([dynamic nodes]) => js_util.callMethod(this, 'after', [nodes]);

  Object replaceWith([dynamic nodes]) =>
      js_util.callMethod(this, 'replaceWith', [nodes]);

  Object remove() => js_util.callMethod(this, 'remove', []);
}

@JS()
@staticInterop
class Slottable {
  external Slottable();
}

extension PropsSlottable on Slottable {
  HTMLSlotElement? get assignedSlot =>
      js_util.getProperty(this, 'assignedSlot');
}

///   objects are collections of nodes, usually returned by
/// properties such as [Node.childNodes] and methods such as
/// [document.querySelectorAll()].
///
///   Note: Although is not an [Array], it is possible to iterate
/// over it with [forEach()]. It can also be converted to a real
/// [Array] using [Array.from()].
///   However, some older browsers have not implemented
/// [NodeList.forEach()] nor [Array.from()]. This can be circumvented
/// by using [Array.prototype.forEach()] — see this document's
/// Example.
///
@JS()
@staticInterop
class NodeList {
  external NodeList();
}

extension PropsNodeList on NodeList {
  ///  Returns an item in the list by its index, or [null] if the index
  /// is out-of-bounds.
  ///    An alternative to accessing [nodeList[i]] (which instead
  /// returns [undefined] when [i] is out-of-bounds). This is mostly
  /// useful for non-JavaScript DOM implementations.
  ///
  /// nodeItem = nodeList.item(index)
  ///
  ///   nodeList is a NodeList. This is usually obtained from
  ///   another DOM property or method, such as childNodes.
  ///
  ///  index is the index of the node to be fetched. The index is zero-based.
  ///
  ///   nodeItem is the indexth node in the nodeList
  ///   returned by the item method.
  ///
  ///
  /// var tables = document.getElementsByTagName("table");
  /// var firstTable = tables.item(1); // or tables[1] - returns the second table in the DOM
  ///
  Node? item(int index) => js_util.callMethod(this, 'item', [index]);

  /// The number of nodes in the [NodeList].
  ///
  int get length => js_util.getProperty(this, 'length');
}

///  The interface represents a generic collection (array-like object
/// similar to [arguments]) of elements (in document order) and
/// offers methods and properties for selecting from the list.
///
///   Note: This interface is called for historical reasons (before
/// the modern DOM, collections implementing this interface could
/// only have HTML elements as their items).
///
///  An in the HTML DOM is live; it is automatically updated when the
/// underlying document is changed. For this reason it is a good idea
/// to make a copy (eg. using [Array.from]) to iterate over if
/// adding, moving, or removing nodes.
@JS()
@staticInterop
class HTMLCollection {
  external HTMLCollection();
}

extension PropsHTMLCollection on HTMLCollection {
  /// Returns the number of items in the collection.
  ///
  int get length => js_util.getProperty(this, 'length');

  ///  Returns the specific node at the given zero-based [index] into
  /// the list. Returns [null] if the [index] is out of range.
  ///    An alternative to accessing [collection[i]] (which instead
  /// returns [undefined] when [i] is out-of-bounds). This is mostly
  /// useful for non-JavaScript DOM implementations.
  ///
  /// var element = HTMLCollection.item(index)
  ///
  /// var c = document.images; // This is an HTMLCollection
  /// var img0 = c.item(0);   // You can use the item() method this way
  /// var img1 = c[1];     // But this notation is easier and more common
  ///
  Element? item(int index) => js_util.callMethod(this, 'item', [index]);

  ///  Returns the specific node whose ID or, as a fallback, name
  /// matches the string specified by [name]. Matching by name is only
  /// done as a last resort, only in HTML, and only if the referenced
  /// element supports the [name] attribute. Returns [null] if no node
  /// exists by the given name.
  ///    An alternative to accessing [collection[name]] (which instead
  /// returns [undefined] when [name] does not exist). This is mostly
  /// useful for non-JavaScript DOM implementations.
  ///
  /// const item = collection.namedItem(key);
  ///
  dynamic namedItem(String name) =>
      js_util.callMethod(this, 'namedItem', [name]);
}

///  The interface provides the ability to watch for changes being
/// made to the DOM tree. It is designed as a replacement for the
/// older Mutation Events feature, which was part of the DOM3 Events
/// specification.
@JS()
@staticInterop
class MutationObserver {
  external MutationObserver(MutationCallback callback);
}

extension PropsMutationObserver on MutationObserver {
  ///  Configures the [MutationObserver] to begin receiving
  /// notifications through its callback function when DOM changes
  /// matching the given options occur.
  ///
  /// mutationObserver.observe(target, options)
  ///
  Object observe(Node target, [MutationObserverInit? options]) =>
      js_util.callMethod(this, 'observe', [target, options]);

  ///  Stops the [MutationObserver] instance from receiving further
  /// notifications until and unless [observe()] is called again.
  ///
  /// mutationObserver.disconnect()
  ///
  ///
  ///  This example creates an observer, then disconnects from it, leaving it available for
  ///  possible reuse.
  ///
  /// const targetNode = document.querySelector("#someElement");
  /// const observerOptions = {
  ///  childList: true,
  ///  attributes: true
  /// }
  ///
  /// const observer = new MutationObserver(callback);
  /// observer.observe(targetNode, observerOptions);
  ///
  /// /* some time later... */
  ///
  /// observer.disconnect();
  ///
  Object disconnect() => js_util.callMethod(this, 'disconnect', []);

  ///  Removes all pending notifications from the [MutationObserver]'s
  /// notification queue and returns them in a new [Array] of
  /// [MutationRecord] objects.
  ///
  /// const mutationRecords = mutationObserver.takeRecords()
  ///
  ///
  ///  In this example, we demonstrate how to handle any undelivered
  ///  MutationRecords by calling takeRecords() just before
  ///  disconnecting the observer.
  ///
  /// const targetNode = document.querySelector("#someElement");
  /// const observerOptions = {
  ///  childList: true,
  ///  attributes: true
  /// }
  ///
  /// const observer = new MutationObserver(callback);
  /// observer.observe(targetNode, observerOptions);
  ///
  /// /* ...later, when it's time to stop observing... */
  ///
  /// /* handle any still-pending mutations */
  ///
  /// let mutations = observer.takeRecords();
  ///
  /// observer.disconnect();
  ///
  /// if (mutations) {
  ///  callback(mutations);
  /// }
  ///  The code in lines 12–17 fetches any unprocessed mutation records, then invokes the
  ///  callback with the records so that they can be processed. This is done immediately prior
  ///  to calling disconnect() to stop observing
  ///  the DOM.
  ///
  Iterable<MutationRecord> takeRecords() =>
      js_util.callMethod(this, 'takeRecords', []);
}

@anonymous
@JS()
@staticInterop
class MutationObserverInit {
  external factory MutationObserverInit(
      {bool childList = false,
      bool? attributes,
      bool? characterData,
      bool? subtree = false,
      bool? attributeOldValue,
      bool? characterDataOldValue,
      Iterable<String>? attributeFilter});
}

extension PropsMutationObserverInit on MutationObserverInit {
  bool get childList => js_util.getProperty(this, 'childList');
  set childList(bool newValue) {
    js_util.setProperty(this, 'childList', newValue);
  }

  bool get attributes => js_util.getProperty(this, 'attributes');
  set attributes(bool newValue) {
    js_util.setProperty(this, 'attributes', newValue);
  }

  bool get characterData => js_util.getProperty(this, 'characterData');
  set characterData(bool newValue) {
    js_util.setProperty(this, 'characterData', newValue);
  }

  bool get subtree => js_util.getProperty(this, 'subtree');
  set subtree(bool newValue) {
    js_util.setProperty(this, 'subtree', newValue);
  }

  bool get attributeOldValue => js_util.getProperty(this, 'attributeOldValue');
  set attributeOldValue(bool newValue) {
    js_util.setProperty(this, 'attributeOldValue', newValue);
  }

  bool get characterDataOldValue =>
      js_util.getProperty(this, 'characterDataOldValue');
  set characterDataOldValue(bool newValue) {
    js_util.setProperty(this, 'characterDataOldValue', newValue);
  }

  Iterable<String> get attributeFilter =>
      js_util.getProperty(this, 'attributeFilter');
  set attributeFilter(Iterable<String> newValue) {
    js_util.setProperty(this, 'attributeFilter', newValue);
  }
}

///  A represents an individual DOM mutation. It is the object that
/// is inside the array passed to [MutationObserver]'s callback.
@JS()
@staticInterop
class MutationRecord {
  external MutationRecord();
}

extension PropsMutationRecord on MutationRecord {
  String get type => js_util.getProperty(this, 'type');
  Node get target => js_util.getProperty(this, 'target');
  NodeList get addedNodes => js_util.getProperty(this, 'addedNodes');
  NodeList get removedNodes => js_util.getProperty(this, 'removedNodes');
  Node? get previousSibling => js_util.getProperty(this, 'previousSibling');
  Node? get nextSibling => js_util.getProperty(this, 'nextSibling');
  String? get attributeName => js_util.getProperty(this, 'attributeName');
  String? get attributeNamespace =>
      js_util.getProperty(this, 'attributeNamespace');
  String? get oldValue => js_util.getProperty(this, 'oldValue');
}

///
///  The DOM interface is an abstract base
///   class upon which many other DOM API objects are based, thus
/// letting those object types
///   to be used similarly and often interchangeably. As an abstract
/// class, there is
///  no such thing as a plain object. All objects that implement
///    functionality are based on one of its subclasses. Most notable
/// are
///  [Document], [Element], and [DocumentFragment].
///   In addition, every kind of DOM node is represented by an
/// interface based on
///  . These include [Attr], [CharacterData]
///  (which [Text], [Comment], [CDATASection] and
///  [ProcessingInstruction] are all based on), and [DocumentType].
///   In some cases, a particular feature of the base interface may
/// not
///   apply to one of its child interfaces; in that case, the
/// inheriting node may
///   return [null] or throw an exception, depending on
/// circumstances. For example,
///   attempting to add children to a node type that cannot have
/// children will throw an
///  exception.
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
@JS()
@staticInterop
class Node implements EventTarget {
  external static int get ELEMENT_NODE;
  external static int get ATTRIBUTE_NODE;
  external static int get TEXT_NODE;
  external static int get CDATA_SECTION_NODE;
  external static int get ENTITY_REFERENCE_NODE;
  external static int get ENTITY_NODE;
  external static int get PROCESSING_INSTRUCTION_NODE;
  external static int get COMMENT_NODE;
  external static int get DOCUMENT_NODE;
  external static int get DOCUMENT_TYPE_NODE;
  external static int get DOCUMENT_FRAGMENT_NODE;
  external static int get NOTATION_NODE;
  external static int get DOCUMENT_POSITION_DISCONNECTED;
  external static int get DOCUMENT_POSITION_PRECEDING;
  external static int get DOCUMENT_POSITION_FOLLOWING;
  external static int get DOCUMENT_POSITION_CONTAINS;
  external static int get DOCUMENT_POSITION_CONTAINED_BY;
  external static int get DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
  external Node();
}

extension PropsNode on Node {
  ///
  ///     Returns an [unsigned short] representing the type of the
  /// node. Possible
  ///    values are:
  ///
  ///
  ///
  ///
  ///      Name
  ///      Value
  ///
  ///
  ///
  ///
  ///      [ELEMENT_NODE]
  ///      [1]
  ///
  ///
  ///      [ATTRIBUTE_NODE]
  ///      [2]
  ///
  ///
  ///      [TEXT_NODE]
  ///      [3]
  ///
  ///
  ///      [CDATA_SECTION_NODE]
  ///      [4]
  ///
  ///
  ///      [PROCESSING_INSTRUCTION_NODE]
  ///      [7]
  ///
  ///
  ///      [COMMENT_NODE]
  ///      [8]
  ///
  ///
  ///      [DOCUMENT_NODE]
  ///      [9]
  ///
  ///
  ///      [DOCUMENT_TYPE_NODE]
  ///      [10]
  ///
  ///
  ///      [DOCUMENT_FRAGMENT_NODE]
  ///      [11]
  ///
  ///
  ///
  ///
  int get nodeType => js_util.getProperty(this, 'nodeType');

  ///
  ///    Returns a [String] containing the name of the [Node]. The
  ///    structure of the name will differ with the node type. E.g. An
  ///     [HTMLElement] will contain the name of the corresponding tag,
  /// like
  ///    ['audio'] for an [HTMLAudioElement], a [Text]
  ///     node will have the ['#text'] string, or a [Document] node
  /// will
  ///    have the ['#document'] string.
  ///
  ///
  String get nodeName => js_util.getProperty(this, 'nodeName');

  ///
  ///    Returns a [String] representing the base URL of the document
  ///    containing the [Node].
  ///
  ///
  String get baseURI => js_util.getProperty(this, 'baseURI');

  ///
  ///     A boolean indicating whether or not the Node is connected
  /// (directly or indirectly)
  ///     to the context object, e.g. the [Document] object in the case
  /// of the
  ///    normal DOM, or the [ShadowRoot] in the case of a shadow DOM.
  ///
  ///
  bool get isConnected => js_util.getProperty(this, 'isConnected');

  ///
  ///     Returns the [Document] that this node belongs to. If the node
  /// is itself
  ///    a document, returns [null].
  ///
  ///
  Document? get ownerDocument => js_util.getProperty(this, 'ownerDocument');

  ///
  ///     Returns the context object's root which optionally includes
  /// the shadow root if it is
  ///    available.
  ///
  ///
  /// getRootNode();
  /// getRootNode(options);
  ///
  Node getRootNode([GetRootNodeOptions? options]) =>
      js_util.callMethod(this, 'getRootNode', [options]);

  ///
  ///     Returns a [Node] that is the parent of this node. If there is
  /// no such
  ///     node, like if this node is the top of the tree or if doesn't
  /// participate in a tree,
  ///    this property returns [null].
  ///
  ///
  Node? get parentNode => js_util.getProperty(this, 'parentNode');

  ///
  ///     Returns an [Element] that is the parent of this node. If the
  /// node has
  ///     no parent, or if that parent is not an [Element], this
  /// property returns
  ///    [null].
  ///
  ///
  Element? get parentElement => js_util.getProperty(this, 'parentElement');

  ///
  ///     Returns a boolean value indicating whether or not the element
  /// has any child
  ///    nodes.
  ///
  ///
  /// hasChildNodes();
  ///
  /// let foo = document.getElementById('foo');
  ///
  /// if (foo.hasChildNodes()) {
  ///  // Do something with 'foo.childNodes'
  /// }
  ///
  bool hasChildNodes() => js_util.callMethod(this, 'hasChildNodes', []);

  ///
  ///     Returns a live [NodeList] containing all the children of this
  /// node
  ///     (including elements, text and comments). [NodeList] being
  /// live means that
  ///     if the children of the [Node] change, the [NodeList] object
  /// is
  ///    automatically updated.
  ///
  ///
  NodeList get childNodes => js_util.getProperty(this, 'childNodes');

  ///
  ///     Returns a [Node] representing the first direct child node of
  /// the node,
  ///    or [null] if the node has no child.
  ///
  ///
  Node? get firstChild => js_util.getProperty(this, 'firstChild');

  ///
  ///     Returns a [Node] representing the last direct child node of
  /// the node,
  ///    or [null] if the node has no child.
  ///
  ///
  Node? get lastChild => js_util.getProperty(this, 'lastChild');

  ///
  ///     Returns a [Node] representing the previous node in the tree,
  /// or
  ///    [null] if there isn't such node.
  ///
  ///
  Node? get previousSibling => js_util.getProperty(this, 'previousSibling');

  ///
  ///    Returns a [Node] representing the next node in the tree, or
  ///    [null] if there isn't such node.
  ///
  ///
  Node? get nextSibling => js_util.getProperty(this, 'nextSibling');

  /// Returns / Sets the value of the current node.
  ///
  String? get nodeValue => js_util.getProperty(this, 'nodeValue');
  set nodeValue(String? newValue) {
    js_util.setProperty(this, 'nodeValue', newValue);
  }

  ///  Returns / Sets the textual content of an element and all its
  /// descendants.
  ///
  String? get textContent => js_util.getProperty(this, 'textContent');
  set textContent(String? newValue) {
    js_util.setProperty(this, 'textContent', newValue);
  }

  ///  Clean up all the text nodes under this element (merge adjacent,
  /// remove empty).
  ///
  /// normalize();
  ///
  /// <output id="result"></output>
  ///
  /// let wrapper = document.createElement("div");
  ///
  /// wrapper.appendChild( document.createTextNode("Part 1 ") );
  /// wrapper.appendChild( document.createTextNode("Part 2 ") );
  ///
  /// let node = wrapper.firstChild;
  /// let result = "Before normalization:<br/>";
  /// while (node) {
  ///  result += " " + node.nodeName + ": " + node.nodeValue + "<br/>";
  ///  node = node.nextSibling;
  /// }
  ///
  /// wrapper.normalize();
  ///
  /// node = wrapper.firstChild;
  /// result += "<br/><br/>After normalization:<br/>";
  /// while (node) {
  ///  result += " " + node.nodeName + ": " + node.nodeValue + "<br/>";
  ///  node = node.nextSibling;
  /// }
  ///
  /// const output = document.getElementById("result");
  /// output.innerHTML = result;
  ///
  Object normalize() => js_util.callMethod(this, 'normalize', []);

  ///
  ///     Clone a [Node], and optionally, all of its contents. By
  /// default, it
  ///    clones the content of the node.
  ///
  ///
  /// cloneNode();
  /// cloneNode(deep);
  ///
  /// let p = document.getElementById("para1")
  /// let p_prime = p.cloneNode(true)
  ///
  Node cloneNode([bool? deep = false]) =>
      js_util.callMethod(this, 'cloneNode', [deep]);

  ///
  ///     Returns a boolean value which indicates whether or not two
  /// nodes are of the
  ///    same type and all their defining data points match.
  ///
  ///
  /// isEqualNode(otherNode);
  ///
  ///
  ///  In this example, we create three <div> blocks. The first and third
  ///  have the same contents and attributes, while the second is different. Then we run some
  ///  JavaScript to compare the nodes using isEqualNode() and output the results.
  ///
  /// <div>This is the first element.</div>
  /// <div>This is the second element.</div>
  /// <div>This is the first element.</div>
  ///
  /// <p id="output"></p>
  ///
  /// ```
  ///
  /// #output {
  ///  width: 440px;
  ///  border: 2px solid black;
  ///  border-radius: 5px;
  ///  padding: 10px;
  ///  margin-top: 20px;
  ///  display: block;
  /// }
  ///
  /// ```
  ///
  /// let output = document.getElementById("output");
  /// let divList = document.getElementsByTagName("div");
  ///
  /// output.innerHTML += "div 0 equals div 0: " + divList[0].isEqualNode(divList[0]) + "<br/>";
  /// output.innerHTML += "div 0 equals div 1: " + divList[0].isEqualNode(divList[1]) + "<br/>";
  /// output.innerHTML += "div 0 equals div 2: " + divList[0].isEqualNode(divList[2]) + "<br/>";
  ///
  /// ```
  ///
  ///
  bool isEqualNode(Node? otherNode) =>
      js_util.callMethod(this, 'isEqualNode', [otherNode]);

  ///
  ///     Returns a boolean value indicating whether or not the two
  /// nodes are
  ///    the same (that is, they reference the same object).
  ///
  ///
  /// isSameNode(otherNode);
  ///
  ///
  ///  In this example, we create three <div> blocks. The first and third
  ///  have the same contents and attributes, while the second is different. Then we run some
  ///  JavaScript to compare the nodes using isSameNode() and output the results.
  ///
  /// <div>This is the first element.</div>
  /// <div>This is the second element.</div>
  /// <div>This is the first element.</div>
  ///
  /// <p id="output"></p>
  ///
  /// ```
  ///
  /// #output {
  ///  width: 440px;
  ///  border: 2px solid black;
  ///  border-radius: 5px;
  ///  padding: 10px;
  ///  margin-top: 20px;
  ///  display: block;
  /// }
  ///
  /// ```
  ///
  /// let output = document.getElementById("output");
  /// let divList = document.getElementsByTagName("div");
  ///
  /// output.innerHTML += "div 0 same as div 0: " + divList[0].isSameNode(divList[0]) + "<br/>";
  /// output.innerHTML += "div 0 same as div 1: " + divList[0].isSameNode(divList[1]) + "<br/>";
  /// output.innerHTML += "div 0 same as div 2: " + divList[0].isSameNode(divList[2]) + "<br/>";
  ///
  /// ```
  ///
  ///
  bool isSameNode(Node? otherNode) =>
      js_util.callMethod(this, 'isSameNode', [otherNode]);

  ///
  ///     Compares the position of the current node against another
  /// node in any other
  ///    document.
  ///
  ///
  /// compareDocumentPosition(otherNode);
  ///
  /// const head = document.head;
  /// const body = document.body;
  ///
  /// if (head.compareDocumentPosition(body) & Node.DOCUMENT_POSITION_FOLLOWING) {
  ///  console.log('Well-formed document');
  /// } else {
  ///  console.error('<head> is not before <body>');
  /// }
  ///
  ///   Note: Because the result returned by compareDocumentPosition() is a bitmask,
  ///   the bitwise AND operator
  ///   must be used for meaningful results.
  ///
  ///
  int compareDocumentPosition(Node other) =>
      js_util.callMethod(this, 'compareDocumentPosition', [other]);

  ///
  ///     Returns [true] or [false] value indicating whether or not a
  /// node is a
  ///    descendant of the calling node.
  ///
  ///
  /// contains(otherNode);
  ///
  ///
  ///  This function checks to see if an element is in the page's body. As
  ///  contains is inclusive and determining if the body contains itself isn't the
  ///  intention of isInPage this case explicitly returns false.
  ///
  /// function isInPage(node) {
  ///  return (node === document.body) ? false : document.body.contains(node);
  /// }
  ///
  bool contains(Node? other) => js_util.callMethod(this, 'contains', [other]);

  ///
  ///     Returns a [DOMString] containing the prefix for a given
  /// namespace URI,
  ///     if present, and [null] if not. When multiple prefixes are
  /// possible, the
  ///    result is implementation-dependent.
  ///
  ///
  /// lookupPrefix(namespace);
  ///
  /// Prefix for <code>http://www.w3.org/2000/svg</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/XML/1998/namespace</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/TR/html4/</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>https://www.w3.org/1999/xlink</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/2000/svg</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>https://www.w3.org/1999/xlink</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Prefix for <code>http://www.w3.org/XML/1998/namespace</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// <svg xmlns:t="http://www.w3.org/2000/svg" height="1"></svg>
  /// <button>Click to see the results</button>
  ///
  /// const button = document.getElementsByTagName('button')[0];
  /// button.addEventListener("click", function () {
  ///  const aHtmlElt = document.getElementsByTagName('output')[0];
  ///  const aSvgElt = document.getElementsByTagName('svg')[0];
  ///
  ///  const result = document.getElementsByTagName('output');
  ///  result[0].value = aHtmlElt.lookupPrefix("http://www.w3.org/2000/svg"); // true
  ///  result[1].value = aHtmlElt.lookupPrefix("http://www.w3.org/XML/1998/namespace"); // false
  ///  result[2].value = aHtmlElt.lookupPrefix("http://www.w3.org/TR/html4/"); // true
  ///  result[3].value = aHtmlElt.lookupPrefix("https://www.w3.org/1999/xlink"); // false
  ///  result[4].value = aSvgElt.lookupPrefix("http://www.w3.org/2000/svg"); // true
  ///  result[5].value = aSvgElt.lookupPrefix("https://www.w3.org/1999/xlink"); // true
  ///  result[6].value = aSvgElt.lookupPrefix("http://www.w3.org/XML/1998/namespace"); // false
  /// });
  ///
  String? lookupPrefix(String? namespace) =>
      js_util.callMethod(this, 'lookupPrefix', [namespace]);

  ///
  ///     Accepts a prefix and returns the namespace URI associated
  /// with it on the given node
  ///    if found (and [null] if not). Supplying [null] for the prefix
  ///    will return the default namespace.
  ///
  ///
  /// lookupNamespaceURI(prefix);
  ///
  /// Namespace URL for <code>xlink</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>xml</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>html</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>``</code> on &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>svg</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>xlink</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Namespace URL for <code>xml</code> on &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// <svg xmlns:svg="http://www.w3.org/2000/svg" height="1"></svg>
  /// <button>Click to see the results</button>
  ///
  /// const button = document.getElementsByTagName('button')[0];
  /// button.addEventListener("click", function () {
  ///  const aHtmlElt = document.getElementsByTagName('output')[0];
  ///  const aSvgElt = document.getElementsByTagName('svg')[0];
  ///
  ///  const result = document.getElementsByTagName('output');
  ///  result[0].value = aHtmlElt.lookupNamespaceURI("xlink");
  ///  result[1].value = aHtmlElt.lookupNamespaceURI("xml");
  ///  result[2].value = aHtmlElt.lookupNamespaceURI("html");
  ///  result[3].value = aHtmlElt.lookupNamespaceURI("");
  ///  result[4].value = aSvgElt.lookupNamespaceURI("svg");
  ///  result[5].value = aSvgElt.lookupNamespaceURI("xlink");
  ///  result[6].value = aSvgElt.lookupNamespaceURI("xml");
  /// });
  ///
  String? lookupNamespaceURI(String? prefix) =>
      js_util.callMethod(this, 'lookupNamespaceURI', [prefix]);

  ///
  ///     Accepts a namespace URI as an argument and returns a boolean
  /// value with a
  ///     value of [true] if the namespace is the default namespace on
  /// the given node
  ///    or [false] if not.
  ///
  ///
  /// isDefaultNamespace(namespaceURI);
  ///
  /// Is "" the default namespace for &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Is "http://www.w3.org/2000/svg" the default namespace for &lt;output&gt;: <output>Not tested</output>.<br/>
  /// Is "" the default namespace for &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// Is "http://www.w3.org/2000/svg" the default namespace for &lt;svg&gt;: <output>Not tested</output>.<br/>
  /// <svg xmlns="http://www.w3.org/2000/svg" height="1"></svg>
  /// <button>Click to see the results</button>
  ///
  /// const button = document.getElementsByTagName('button')[0];
  /// button.addEventListener("click", function () {
  ///  const aHtmlElt = document.getElementsByTagName('output')[0];
  ///  const aSvgElt = document.getElementsByTagName('svg')[0];
  ///
  ///  const result = document.getElementsByTagName('output');
  ///  result[0].value = aHtmlElt.isDefaultNamespace(""); // true
  ///  result[1].value = aHtmlElt.isDefaultNamespace("http://www.w3.org/2000/svg"); // false
  ///  result[2].value = aSvgElt.isDefaultNamespace(""); // true
  ///  result[3].value = aSvgElt.isDefaultNamespace("http://www.w3.org/2000/svg"); // false
  /// });
  ///
  bool isDefaultNamespace(String? namespace) =>
      js_util.callMethod(this, 'isDefaultNamespace', [namespace]);

  ///
  ///     Inserts a [Node] before the reference node as a child of a
  /// specified
  ///    parent node.
  ///
  ///
  /// insertBefore(newNode, referenceNode);
  ///
  Node insertBefore(Node node, Node? child) =>
      js_util.callMethod(this, 'insertBefore', [node, child]);

  ///
  ///    Adds the specified [childNode] argument as the last child to
  ///    the current node.
  ///     If the argument referenced an existing node on the DOM tree,
  /// the node will be detached
  ///    from its current position and attached at the new position.
  ///
  ///
  /// appendChild(aChild);
  ///
  /// // Create a new paragraph element, and append it to the end of the document body
  /// let p = document.createElement("p");
  /// document.body.appendChild(p);
  ///
  Node appendChild(Node node) =>
      js_util.callMethod(this, 'appendChild', [node]);

  ///
  ///     Replaces one child [Node] of the current one with the second
  /// one given
  ///    in parameter.
  ///
  ///
  /// replaceChild(newChild, oldChild);
  ///
  /// // Given:
  /// // <div>
  /// // <span id="childSpan">foo bar</span>
  /// // </div>
  ///
  /// // Create an empty element node
  /// // without an ID, any attributes, or any content
  /// const sp1 = document.createElement("span");
  ///
  /// // Give it an id attribute called 'newSpan'
  /// sp1.id = "newSpan";
  ///
  /// // Create some content for the new element.
  /// const sp1_content = document.createTextNode("new replacement span element.");
  ///
  /// // Apply that content to the new element
  /// sp1.appendChild(sp1_content);
  ///
  /// // Build a reference to the existing node to be replaced
  /// const sp2 = document.getElementById("childSpan");
  /// const parentDiv = sp2.parentNode;
  ///
  /// // Replace existing node sp2 with the new span element sp1
  /// parentDiv.replaceChild(sp1, sp2);
  ///
  /// // Result:
  /// // <div>
  /// //  <span id="newSpan">new replacement span element.</span>
  /// // </div>
  ///
  Node replaceChild(Node node, Node child) =>
      js_util.callMethod(this, 'replaceChild', [node, child]);

  ///
  ///     Removes a child node from the current element, which must be
  /// a child of the current
  ///    node.
  ///
  ///
  /// removeChild(child);
  ///
  Node removeChild(Node child) =>
      js_util.callMethod(this, 'removeChild', [child]);
}

@anonymous
@JS()
@staticInterop
class GetRootNodeOptions {
  external factory GetRootNodeOptions({bool composed = false});
}

extension PropsGetRootNodeOptions on GetRootNodeOptions {
  bool get composed => js_util.getProperty(this, 'composed');
  set composed(bool newValue) {
    js_util.setProperty(this, 'composed', newValue);
  }
}

///  The interface represents any web page loaded in the browser and
/// serves as an entry point into the web page's content, which is
/// the DOM tree.
///  The DOM tree includes elements such as [<body>] and [<table>],
/// among many others. It provides functionality globally to the
/// document, like how to obtain the page's URL and create new
/// elements in the document.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Document
///
///
///  The interface describes the common properties and methods for
/// any kind of document. Depending on the document's type (e.g.
/// HTML, XML, SVG, …), a larger API is available: HTML documents,
/// served with the ["text/html"] content type, also implement the
/// [HTMLDocument] interface, whereas XML and SVG documents implement
/// the [XMLDocument] interface.
@JS()
@staticInterop
class Document
    implements
        Node,
        GeometryUtils,
        FontFaceSource,
        NonElementParentNode,
        DocumentOrShadowRoot,
        ParentNode,
        XPathEvaluatorBase,
        GlobalEventHandlers,
        DocumentAndElementEventHandlers {
  external Document();
}

extension PropsDocument on Document {
  ///  Returns the DOM implementation associated with the current
  /// document.
  ///
  DOMImplementation get implementation =>
      js_util.getProperty(this, 'implementation');
  String get URL => js_util.getProperty(this, 'URL');

  /// Returns the document location as a string.
  ///
  String get documentURI => js_util.getProperty(this, 'documentURI');

  ///  Indicates whether the document is rendered in quirks or strict
  /// mode.
  ///
  @experimental
  String get compatMode => js_util.getProperty(this, 'compatMode');

  /// Returns the character set being used by the document.
  ///
  String get characterSet => js_util.getProperty(this, 'characterSet');
  String get charset => js_util.getProperty(this, 'charset');
  String get inputEncoding => js_util.getProperty(this, 'inputEncoding');

  ///  Returns the Content-Type from the MIME Header of the current
  /// document.
  ///
  @experimental
  String get contentType => js_util.getProperty(this, 'contentType');

  ///  Returns the Document Type Definition (DTD) of the current
  /// document.
  ///
  DocumentType? get doctype => js_util.getProperty(this, 'doctype');

  ///  Returns the [Element] that is a direct child of the document.
  /// For HTML documents, this is normally the [HTMLHtmlElement] object
  /// representing the document's [<html>] element.
  ///
  Element? get documentElement => js_util.getProperty(this, 'documentElement');

  /// Returns a list of elements with the given tag name.
  ///
  /// var elements = document.getElementsByTagName(name);
  ///
  ///   elements is a live HTMLCollection (but see the note below)
  ///   of found elements in the order they appear in the tree.
  ///
  ///
  ///   name is a string representing the name of the elements. The special
  ///   string "*" represents all elements.
  ///
  ///
  ///   Note: The
  /// latest W3C specification says elements is an
  ///   HTMLCollection; however, this method returns a NodeList in
  ///   WebKit browsers. See bug 14869 for details.
  ///
  ///
  ///
  ///  In the following example, getElementsByTagName() starts from a particular
  ///  parent element and searches top-down recursively through the DOM from that parent
  ///  element, building a collection of all descendant elements which match the tag
  ///  name parameter. This demonstrates both
  ///  document.getElementsByTagName() and the functionally identical
  ///  Element.getElementsByTagName(), which starts the search at a specific
  ///  element within the DOM tree.
  ///  Clicking the buttons uses getElementsByTagName() to count the descendant
  ///  paragraph elements of a particular parent (either the document itself or one of two
  ///  nested <div> elements).
  ///
  /// <!DOCTYPE html>
  /// <html lang="en">
  /// <head>
  ///  <meta charset="UTF-8" />
  ///  <title>getElementsByTagName example</title>
  ///  <script>
  ///   function getAllParaElems() {
  ///    var allParas = document.getElementsByTagName('p');
  ///    var num = allParas.length;
  ///    alert('There are ' + num + ' paragraph in this document');
  ///   }
  ///
  ///   function div1ParaElems() {
  ///    var div1 = document.getElementById('div1');
  ///    var div1Paras = div1.getElementsByTagName('p');
  ///    var num = div1Paras.length;
  ///    alert('There are ' + num + ' paragraph in #div1');
  ///   }
  ///
  ///   function div2ParaElems() {
  ///    var div2 = document.getElementById('div2');
  ///    var div2Paras = div2.getElementsByTagName('p');
  ///    var num = div2Paras.length;
  ///    alert('There are ' + num + ' paragraph in #div2');
  ///   }
  ///  </script>
  /// </head>
  /// <body style="border: solid green 3px">
  ///  <p>Some outer text</p>
  ///  <p>Some outer text</p>
  ///
  ///  <div id="div1" style="border: solid blue 3px">
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///
  ///   <div id="div2" style="border: solid red 3px">
  ///    <p>Some div2 text</p>
  ///    <p>Some div2 text</p>
  ///   </div>
  ///  </div>
  ///
  ///  <p>Some outer text</p>
  ///  <p>Some outer text</p>
  ///
  ///  <button onclick="getAllParaElems();">
  ///   show all p elements in document</button><br />
  ///
  ///  <button onclick="div1ParaElems();">
  ///   show all p elements in div1 element</button><br />
  ///
  ///  <button onclick="div2ParaElems();">
  ///   show all p elements in div2 element</button>
  ///
  /// </body>
  /// </html>
  ///
  HTMLCollection getElementsByTagName(String qualifiedName) =>
      js_util.callMethod(this, 'getElementsByTagName', [qualifiedName]);

  ///  Returns a list of elements with the given tag name and
  /// namespace.
  ///
  /// elements = document.getElementsByTagNameNS(namespace, name)
  ///
  ///   elements is a live NodeList (but see the note below) of
  ///   found elements in the order they appear in the tree.
  ///
  ///
  ///   namespace is the namespace URI of elements to look for (see
  ///   element.namespaceURI).
  ///
  ///
  ///   name is either the local name of elements to look for or the special
  ///   value *, which matches all elements (see element.localName).
  ///
  ///
  ///   Note: While the W3C specification says elements is a NodeList, this method returns a HTMLCollection both in Gecko and Internet Explorer.
  ///   Opera returns a NodeList, but with a namedItem method implemented, which makes it similar to a HTMLCollection. As of January 2012, only in WebKit browsers is the returned value a pure NodeList.
  ///   See bug 14869 for details.
  ///
  ///
  ///   Note: Currently parameters in this method are case-sensitive, but they were case-insensitive in Firefox 3.5 and before.
  ///   See the developer release note for Firefox 3.6 and a note in Browser compatibility section in Element.getElementsByTagNameNS for details.
  ///
  ///
  ///
  ///  In the following example getElementsByTagNameNS starts from a particular
  ///  parent element, and searches topdown recursively through the DOM from that parent
  ///  element, looking for child elements matching the tag name parameter.
  ///  Note that when the node on which getElementsByTagName is invoked is not
  ///  the document node, in fact the
  ///  element.getElementsByTagNameNS method is used.
  ///  To use the following example, just copy/paste it into a new file saved with the .xhtml
  ///  extension.
  ///
  /// <html xmlns="http://www.w3.org/1999/xhtml">
  ///
  /// <head>
  /// <title>getElementsByTagNameNS example</title>
  ///
  /// <script type="text/javascript">
  ///
  /// function getAllParaElems()
  /// {
  ///  var allParas = document.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "p");
  ///
  ///  var num = allParas.length;
  ///
  ///  alert("There are " + num + " &lt;p&gt; elements in this document");
  /// }
  ///
  /// function div1ParaElems()
  /// {
  ///  var div1 = document.getElementById("div1")
  ///  var div1Paras = div1.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "p");
  ///
  ///  var num = div1Paras.length;
  ///
  ///  alert("There are " + num + " &lt;p&gt; elements in div1 element");
  /// }
  ///
  /// function div2ParaElems()
  /// {
  ///  var div2 = document.getElementById("div2")
  ///  var div2Paras = div2.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "p");
  ///
  ///  var num = div2Paras.length;
  ///
  ///  alert("There are " + num + " &lt;p&gt; elements in div2 element");
  /// }
  ///
  /// </script>
  /// </head>
  ///
  /// <body style="border: solid green 3px">
  /// <p>Some outer text</p>
  /// <p>Some outer text</p>
  ///
  ///  <div id="div1" style="border: solid blue 3px">
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///   <p>Some div1 text</p>
  ///
  ///   <div id="div2" style="border: solid red 3px">
  ///   <p>Some div2 text</p>
  ///   <p>Some div2 text</p>
  ///   </div>
  ///  </div>
  ///
  /// <p>Some outer text</p>
  /// <p>Some outer text</p>
  ///
  /// <button onclick="getAllParaElems();">
  ///  show all p elements in document</button><br />
  ///
  /// <button onclick="div1ParaElems();">
  ///  show all p elements in div1 element</button><br />
  ///
  /// <button onclick="div2ParaElems();">
  ///  show all p elements in div2 element</button>
  ///
  /// </body>
  /// </html>
  ///
  HTMLCollection getElementsByTagNameNS(String? namespace, String localName) =>
      js_util
          .callMethod(this, 'getElementsByTagNameNS', [namespace, localName]);

  /// Returns a list of elements with the given class name.
  ///
  /// var elements = document.getElementsByClassName(names); // or:
  /// var elements = rootElement.getElementsByClassName(names);
  ///  elements is a live HTMLCollection of found elements.
  ///
  ///   names is a string representing the class name(s) to match; multiple class
  ///   names are separated by whitespace
  ///
  ///
  ///   getElementsByClassName can be
  ///   called on any element, not only on the document. The element on which
  ///   it is called will be used as the root of the search.
  ///
  ///
  HTMLCollection getElementsByClassName(String classNames) =>
      js_util.callMethod(this, 'getElementsByClassName', [classNames]);

  /// Creates a new element with the given tag name.
  ///
  /// let element = document.createElement(tagName[, options]);
  ///
  Element createElement(String localName, [dynamic options]) =>
      js_util.callMethod(this, 'createElement', [localName, options]);

  /// Creates a new element with the given tag name and namespace URI.
  ///
  /// var element = document.createElementNS(namespaceURI, qualifiedName[, options]);
  ///
  ///
  ///  This creates a new <div> element in the XHTML namespace and
  ///  appends it to the vbox element. Although this is not an extremely useful XUL document, it does demonstrate the use of
  ///  elements from two different namespaces within a single document:
  ///
  /// <?xml version="1.0"?>
  /// <page xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
  ///    xmlns:html="http://www.w3.org/1999/xhtml"
  ///    title="||Working with elements||"
  ///    onload="init()">
  ///
  /// <script type="application/javascript"><![CDATA[
  ///  let container;
  ///  let newdiv;
  ///  let txtnode;
  ///
  ///  function init(){
  ///   container = document.getElementById("ContainerBox");
  ///   newdiv = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
  ///   txtnode = document.createTextNode("This is text that was constructed dynamically with createElementNS and createTextNode then inserted into the document using appendChild.");
  ///   newdiv.appendChild(txtnode);
  ///   container.appendChild(newdiv);
  ///  }
  ///
  /// ]]></script>
  ///
  ///  <vbox id="ContainerBox" flex="1">
  ///  <html:div>
  ///   The script on this page will add dynamic content below:
  ///  </html:div>
  ///  </vbox>
  ///
  /// </page>
  ///
  ///   Note: The example given above uses inline script which is not recommended in XHTML
  ///   documents. This particular example is actually an XUL document with embedded XHTML,
  ///   however, the recommendation still applies.
  ///
  ///
  Element createElementNS(String? namespace, String qualifiedName,
          [dynamic options]) =>
      js_util.callMethod(
          this, 'createElementNS', [namespace, qualifiedName, options]);

  /// Creates a new document fragment.
  ///
  /// var fragment = document.createDocumentFragment();
  ///
  ///
  ///  This example creates a list of major web browsers in a DocumentFragment,
  ///  then adds the new DOM subtree to the document to be displayed.
  ///
  /// <ul id="ul">
  /// </ul>
  ///
  /// ```
  ///
  /// var element = document.getElementById('ul'); // assuming ul exists
  /// var fragment = document.createDocumentFragment();
  /// var browsers = ['Firefox', 'Chrome', 'Opera',
  ///   'Safari', 'Internet Explorer'];
  ///
  /// browsers.forEach(function(browser) {
  ///   var li = document.createElement('li');
  ///   li.textContent = browser;
  ///   fragment.appendChild(li);
  /// });
  ///
  /// element.appendChild(fragment);
  ///
  /// ```
  ///
  DocumentFragment createDocumentFragment() =>
      js_util.callMethod(this, 'createDocumentFragment', []);

  /// Creates a text node.
  ///
  /// var text = document.createTextNode(data);
  ///  text is a Text node.
  ///
  ///   data is a string
  ///   containing the data to be put in the text node.
  ///
  ///
  /// <!DOCTYPE html>
  /// <html lang="en">
  /// <head>
  /// <title>createTextNode example</title>
  /// <script>
  /// function addTextNode(text) {
  ///  var newtext = document.createTextNode(text),
  ///    p1 = document.getElementById("p1");
  ///
  ///  p1.appendChild(newtext);
  /// }
  /// </script>
  /// </head>
  ///
  /// <body>
  ///  <button onclick="addTextNode('YES! ');">YES!</button>
  ///  <button onclick="addTextNode('NO! ');">NO!</button>
  ///  <button onclick="addTextNode('WE CAN! ');">WE CAN!</button>
  ///
  ///  <hr />
  ///
  ///  <p id="p1">First line of paragraph.</p>
  /// </body>
  /// </html>
  ///
  Text createTextNode(String data) =>
      js_util.callMethod(this, 'createTextNode', [data]);

  /// Creates a new CDATA node and returns it.
  ///
  /// var CDATASectionNode = document.createCDATASection(data);
  ///  CDATASectionNode is a CDATA
  /// Section node.
  ///  data is a string containing the data to be added to the CDATA Section.
  ///
  /// var docu = new DOMParser().parseFromString('<xml></xml>', 'application/xml')
  ///
  /// var cdata = docu.createCDATASection('Some <CDATA> data & then some');
  ///
  /// docu.getElementsByTagName('xml')[0].appendChild(cdata);
  ///
  /// alert(new XMLSerializer().serializeToString(docu));
  /// // Displays: <xml><![CDATA[Some <CDATA> data & then some]]></xml>
  ///
  CDATASection createCDATASection(String data) =>
      js_util.callMethod(this, 'createCDATASection', [data]);

  /// Creates a new comment node and returns it.
  ///
  /// CommentNode = document.createComment(data);
  ///
  /// var docu = new DOMParser().parseFromString('<xml></xml>', 'application/xml');
  /// var comment = docu.createComment('This is a not-so-secret comment in your document');
  ///
  /// docu.getElementsByTagName('xml')[0].appendChild(comment);
  ///
  /// alert(new XMLSerializer().serializeToString(docu));
  /// // Displays: <xml><!--This is a not-so-secret comment in your document--></xml>
  ///
  Comment createComment(String data) =>
      js_util.callMethod(this, 'createComment', [data]);

  /// Creates a new [ProcessingInstruction] object.
  ///
  /// piNode = document.createProcessingInstruction(target, data)
  ///
  /// var doc = new DOMParser().parseFromString('<foo />', 'application/xml');
  /// var pi = doc.createProcessingInstruction('xml-stylesheet', 'href="mycss.css" type="text/css"');
  ///
  /// doc.insertBefore(pi, doc.firstChild);
  ///
  /// console.log(new XMLSerializer().serializeToString(doc));
  /// // Displays: <?xml-stylesheet href="mycss.css" type="text/css"?><foo/>
  ///
  ProcessingInstruction createProcessingInstruction(
          String target, String data) =>
      js_util.callMethod(this, 'createProcessingInstruction', [target, data]);

  /// Returns a clone of a node from an external document.
  ///
  /// importNode(externalNode)
  /// importNode(externalNode, deep)
  ///
  /// const iframe = document.querySelector("iframe");
  /// const oldNode = iframe.contentWindow.document.getElementById("myNode");
  /// const newNode = document.importNode(oldNode, true);
  /// document.getElementById("container").appendChild(newNode);
  ///
  Node importNode(Node node, [bool? deep = false]) =>
      js_util.callMethod(this, 'importNode', [node, deep]);

  /// Adopt node from an external document.
  ///
  /// const importedNode = document.adoptNode(externalNode);
  ///
  /// const iframe = document.querySelector('iframe');
  /// const iframeImages = iframe.contentDocument.querySelectorAll('img');
  /// const newParent = document.getElementById('images');
  ///
  /// iframeImages.forEach(function(imgEl) {
  ///  newParent.appendChild(document.adoptNode(imgEl));
  /// });
  ///
  Node adoptNode(Node node) => js_util.callMethod(this, 'adoptNode', [node]);

  /// Creates a new [Attr] object and returns it.
  ///
  /// attribute = document.createAttribute(name)
  ///
  /// var node = document.getElementById("div1");
  /// var a = document.createAttribute("my_attrib");
  /// a.value = "newVal";
  /// node.setAttributeNode(a);
  /// console.log(node.getAttribute("my_attrib")); // "newVal"
  ///
  Attr createAttribute(String localName) =>
      js_util.callMethod(this, 'createAttribute', [localName]);

  ///  Creates a new attribute node in a given namespace and returns
  /// it.
  ///
  Attr createAttributeNS(String? namespace, String qualifiedName) =>
      js_util.callMethod(this, 'createAttributeNS', [namespace, qualifiedName]);

  /// Creates an event object.
  ///
  /// var event = document.createEvent(type);
  ///  event is the created Event object.
  ///
  ///   type is a string that represents the type of event to be
  ///   created. Possible event types include "UIEvents",
  ///   "MouseEvents", "MutationEvents", and
  ///   "HTMLEvents". See Notes section for details.
  ///
  ///
  /// // Create the event.
  /// var event = document.createEvent('Event');
  ///
  /// // Define that the event name is 'build'.
  /// event.initEvent('build', true, true);
  ///
  /// // Listen for the event.
  /// elem.addEventListener('build', function (e) {
  ///  // e.target matches elem
  /// }, false);
  ///
  /// // Target can be any Element or other EventTarget.
  /// elem.dispatchEvent(event);
  ///
  Event createEvent(String mInterface) =>
      js_util.callMethod(this, 'createEvent', [mInterface]);

  /// Creates a [Range] object.
  ///
  /// range = document.createRange();
  ///
  /// range is the created Range object.
  /// let range = document.createRange();
  ///
  /// range.setStart(startNode, startOffset);
  /// range.setEnd(endNode, endOffset);
  ///
  Range createRange() => js_util.callMethod(this, 'createRange', []);

  /// Creates a [NodeIterator] object.
  ///
  /// const nodeIterator = document.createNodeIterator(root[, whatToShow[, filter]]);
  ///
  /// const nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   {
  ///    acceptNode(node) {
  ///     return node.nodeName.toLowerCase() === 'p' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
  ///    }
  ///   }
  /// );
  /// const pars = [];
  /// let currentNode;
  ///
  /// while (currentNode = nodeIterator.nextNode()) {
  ///  pars.push(currentNode);
  /// }
  ///
  NodeIterator createNodeIterator(Node root,
          [int? whatToShow = 0xFFFFFFFF, NodeFilter? filter]) =>
      js_util
          .callMethod(this, 'createNodeIterator', [root, whatToShow, filter]);

  /// Creates a [TreeWalker] object.
  ///
  /// document.createTreeWalker(root[, whatToShow[, filter[, expandEntityReferences]]]);
  ///
  ///
  ///  The following example goes through all nodes in the body,
  ///  filters out any non nodes that aren't elements (with the `NodeFilter.SHOW_ELEMENT` value),
  ///  marks each remaining node as acceptable (The acceptNode() method could make
  ///  a different decision.), and then makes use of tree walker iterator
  ///  that is created to advance through the nodes (now all elements) and push them into an
  ///  array.
  ///
  /// var treeWalker = document.createTreeWalker(
  ///  document.body,
  ///  NodeFilter.SHOW_ELEMENT,
  ///  { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///  false
  /// );
  ///
  /// var nodeList = [];
  /// var currentNode = treeWalker.currentNode;
  ///
  /// while(currentNode) {
  ///  nodeList.push(currentNode);
  ///  currentNode = treeWalker.nextNode();
  /// }
  ///
  TreeWalker createTreeWalker(Node root,
          [int? whatToShow = 0xFFFFFFFF, NodeFilter? filter]) =>
      js_util.callMethod(this, 'createTreeWalker', [root, whatToShow, filter]);

  bool get hidden => js_util.getProperty(this, 'hidden');
  VisibilityState get visibilityState =>
      js_util.getProperty(this, 'visibilityState');
  EventHandlerNonNull? get onvisibilitychange =>
      js_util.getProperty(this, 'onvisibilitychange');
  set onvisibilitychange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onvisibilitychange', newValue);
  }

  Future<bool> hasStorageAccess() =>
      js_util.promiseToFuture(js_util.callMethod(this, 'hasStorageAccess', []));

  Future<Object> requestStorageAccess() => js_util
      .promiseToFuture(js_util.callMethod(this, 'requestStorageAccess', []));

  Selection? getSelection() => js_util.callMethod(this, 'getSelection', []);

  DocumentTimeline get timeline => js_util.getProperty(this, 'timeline');
  Element? elementFromPoint(double x, double y) =>
      js_util.callMethod(this, 'elementFromPoint', [x, y]);

  Iterable<Element> elementsFromPoint(double x, double y) =>
      js_util.callMethod(this, 'elementsFromPoint', [x, y]);

  CaretPosition? caretPositionFromPoint(double x, double y) =>
      js_util.callMethod(this, 'caretPositionFromPoint', [x, y]);

  Element? get scrollingElement =>
      js_util.getProperty(this, 'scrollingElement');
  EventHandlerNonNull? get onpointerlockchange =>
      js_util.getProperty(this, 'onpointerlockchange');
  set onpointerlockchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onpointerlockchange', newValue);
  }

  EventHandlerNonNull? get onpointerlockerror =>
      js_util.getProperty(this, 'onpointerlockerror');
  set onpointerlockerror(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onpointerlockerror', newValue);
  }

  Object exitPointerLock() => js_util.callMethod(this, 'exitPointerLock', []);

  bool get fullscreenEnabled => js_util.getProperty(this, 'fullscreenEnabled');
  bool get fullscreen => js_util.getProperty(this, 'fullscreen');
  Future<Object> exitFullscreen() =>
      js_util.promiseToFuture(js_util.callMethod(this, 'exitFullscreen', []));

  EventHandlerNonNull? get onfullscreenchange =>
      js_util.getProperty(this, 'onfullscreenchange');
  set onfullscreenchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenchange', newValue);
  }

  EventHandlerNonNull? get onfullscreenerror =>
      js_util.getProperty(this, 'onfullscreenerror');
  set onfullscreenerror(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenerror', newValue);
  }

  bool get pictureInPictureEnabled =>
      js_util.getProperty(this, 'pictureInPictureEnabled');
  Future<Object> exitPictureInPicture() => js_util
      .promiseToFuture(js_util.callMethod(this, 'exitPictureInPicture', []));

  EventHandlerNonNull? get onfreeze => js_util.getProperty(this, 'onfreeze');
  set onfreeze(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfreeze', newValue);
  }

  EventHandlerNonNull? get onresume => js_util.getProperty(this, 'onresume');
  set onresume(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onresume', newValue);
  }

  bool get wasDiscarded => js_util.getProperty(this, 'wasDiscarded');
  NamedFlowMap get namedFlows => js_util.getProperty(this, 'namedFlows');
  SVGSVGElement? get rootElement => js_util.getProperty(this, 'rootElement');
  FragmentDirective get fragmentDirective =>
      js_util.getProperty(this, 'fragmentDirective');
  Future<InterestCohort> interestCohort() =>
      js_util.promiseToFuture(js_util.callMethod(this, 'interestCohort', []));

  PermissionsPolicy get permissionsPolicy =>
      js_util.getProperty(this, 'permissionsPolicy');
  Location? get location => js_util.getProperty(this, 'location');
  String get domain => js_util.getProperty(this, 'domain');
  set domain(String newValue) {
    js_util.setProperty(this, 'domain', newValue);
  }

  String get referrer => js_util.getProperty(this, 'referrer');
  String get cookie => js_util.getProperty(this, 'cookie');
  set cookie(String newValue) {
    js_util.setProperty(this, 'cookie', newValue);
  }

  String get lastModified => js_util.getProperty(this, 'lastModified');
  DocumentReadyState get readyState => js_util.getProperty(this, 'readyState');
  String get title => js_util.getProperty(this, 'title');
  set title(String newValue) {
    js_util.setProperty(this, 'title', newValue);
  }

  String get dir => js_util.getProperty(this, 'dir');
  set dir(String newValue) {
    js_util.setProperty(this, 'dir', newValue);
  }

  HTMLElement? get body => js_util.getProperty(this, 'body');
  set body(HTMLElement? newValue) {
    js_util.setProperty(this, 'body', newValue);
  }

  HTMLHeadElement? get head => js_util.getProperty(this, 'head');
  HTMLCollection get images => js_util.getProperty(this, 'images');
  HTMLCollection get embeds => js_util.getProperty(this, 'embeds');
  HTMLCollection get plugins => js_util.getProperty(this, 'plugins');
  HTMLCollection get links => js_util.getProperty(this, 'links');
  HTMLCollection get forms => js_util.getProperty(this, 'forms');
  HTMLCollection get scripts => js_util.getProperty(this, 'scripts');
  NodeList getElementsByName(String elementName) =>
      js_util.callMethod(this, 'getElementsByName', [elementName]);

  dynamic get currentScript => js_util.getProperty(this, 'currentScript');
  Window? open(String url, [String? name, String? features]) =>
      js_util.callMethod(this, 'open', [url, name, features]);

  Object close() => js_util.callMethod(this, 'close', []);

  Object write([String? text]) => js_util.callMethod(this, 'write', [text]);

  Object writeln([String? text]) => js_util.callMethod(this, 'writeln', [text]);

  Window? get defaultView => js_util.getProperty(this, 'defaultView');
  bool hasFocus() => js_util.callMethod(this, 'hasFocus', []);

  String get designMode => js_util.getProperty(this, 'designMode');
  set designMode(String newValue) {
    js_util.setProperty(this, 'designMode', newValue);
  }

  bool execCommand(String commandId,
          [bool? showUI = false, String? value = '']) =>
      js_util.callMethod(this, 'execCommand', [commandId, showUI, value]);

  bool queryCommandEnabled(String commandId) =>
      js_util.callMethod(this, 'queryCommandEnabled', [commandId]);

  bool queryCommandIndeterm(String commandId) =>
      js_util.callMethod(this, 'queryCommandIndeterm', [commandId]);

  bool queryCommandState(String commandId) =>
      js_util.callMethod(this, 'queryCommandState', [commandId]);

  bool queryCommandSupported(String commandId) =>
      js_util.callMethod(this, 'queryCommandSupported', [commandId]);

  String queryCommandValue(String commandId) =>
      js_util.callMethod(this, 'queryCommandValue', [commandId]);

  EventHandlerNonNull? get onreadystatechange =>
      js_util.getProperty(this, 'onreadystatechange');
  set onreadystatechange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onreadystatechange', newValue);
  }

  String get fgColor => js_util.getProperty(this, 'fgColor');
  set fgColor(String newValue) {
    js_util.setProperty(this, 'fgColor', newValue);
  }

  String get linkColor => js_util.getProperty(this, 'linkColor');
  set linkColor(String newValue) {
    js_util.setProperty(this, 'linkColor', newValue);
  }

  String get vlinkColor => js_util.getProperty(this, 'vlinkColor');
  set vlinkColor(String newValue) {
    js_util.setProperty(this, 'vlinkColor', newValue);
  }

  String get alinkColor => js_util.getProperty(this, 'alinkColor');
  set alinkColor(String newValue) {
    js_util.setProperty(this, 'alinkColor', newValue);
  }

  String get bgColor => js_util.getProperty(this, 'bgColor');
  set bgColor(String newValue) {
    js_util.setProperty(this, 'bgColor', newValue);
  }

  HTMLCollection get anchors => js_util.getProperty(this, 'anchors');
  HTMLCollection get applets => js_util.getProperty(this, 'applets');
  Object clear() => js_util.callMethod(this, 'clear', []);

  Object captureEvents() => js_util.callMethod(this, 'captureEvents', []);

  Object releaseEvents() => js_util.callMethod(this, 'releaseEvents', []);

  HTMLAllCollection get all => js_util.getProperty(this, 'all');
  FontMetrics measureElement(Element element) =>
      js_util.callMethod(this, 'measureElement', [element]);

  FontMetrics measureText(String text, StylePropertyMapReadOnly styleMap) =>
      js_util.callMethod(this, 'measureText', [text, styleMap]);
}

///  The XMLDocument interface represents an XML document. It
/// inherits from the generic [Document] and does not add any
/// specific methods or properties to it: nevertheless, several
/// algorithms behave differently with the two types of documents.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Document
///
///
///
///
///
///    XMLDocument
///
///
@JS()
@staticInterop
class XMLDocument implements Document {
  external XMLDocument();
}

@anonymous
@JS()
@staticInterop
class ElementCreationOptions {
  external factory ElementCreationOptions({String mIs});
}

extension PropsElementCreationOptions on ElementCreationOptions {
  @JS('is')
  @staticInterop
  String get mIs => js_util.getProperty(this, 'is');
  set mIs(String newValue) {
    js_util.setProperty(this, 'is', newValue);
  }
}

///  The interface represents an object providing methods which are
/// not dependent on any particular document. Such an object is
/// returned by the [Document.implementation] property.
@JS()
@staticInterop
class DOMImplementation {
  external DOMImplementation();
}

extension PropsDOMImplementation on DOMImplementation {
  /// Creates and returns a [DocumentType].
  ///
  /// var doctype = document.implementation.createDocumentType(qualifiedNameStr, publicId, systemId);
  ///
  /// var dt = document.implementation.createDocumentType('svg:svg', '-//W3C//DTD SVG 1.1//EN', 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd');
  /// var d = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg:svg', dt);
  /// alert(d.doctype.publicId); // -//W3C//DTD SVG 1.1//EN
  ///
  DocumentType createDocumentType(
          String qualifiedName, String publicId, String systemId) =>
      js_util.callMethod(
          this, 'createDocumentType', [qualifiedName, publicId, systemId]);

  /// Creates and returns an [XMLDocument].
  ///
  /// var doc = document.implementation.createDocument(namespaceURI, qualifiedNameStr, documentType);
  ///
  /// var doc = document.implementation.createDocument ('http://www.w3.org/1999/xhtml', 'html', null);
  /// var body = document.createElementNS('http://www.w3.org/1999/xhtml', 'body');
  /// body.setAttribute('id', 'abc');
  /// doc.documentElement.appendChild(body);
  /// alert(doc.getElementById('abc')); // [object HTMLBodyElement]
  ///
  XMLDocument createDocument(String? namespace, String qualifiedName,
          [DocumentType? doctype]) =>
      js_util.callMethod(
          this, 'createDocument', [namespace, qualifiedName, doctype]);

  /// Creates and returns an HTML [Document].
  ///
  /// const newDoc = document.implementation.createHTMLDocument(title)
  ///
  /// This example creates a new HTML document and inserts it into an <iframe> in the current document.
  /// Here's the HTML for this example:
  /// <body>
  ///  <p>Click <a href="javascript:makeDocument()">here</a> to create a new document and insert it below.</p>
  ///  <iframe id="theFrame" src="about:blank" />
  /// </body>
  ///
  /// The JavaScript implementation of makeDocument() follows:
  /// function makeDocument() {
  ///  let frame = document.getElementById("theFrame");
  ///
  ///  let doc = document.implementation.createHTMLDocument("New Document");
  ///  let p = doc.createElement("p");
  ///  p.textContent = "This is a new paragraph.";
  ///
  ///  try {
  ///   doc.body.appendChild(p);
  ///  } catch(e) {
  ///   console.log(e);
  ///  }
  ///
  ///  // Copy the new HTML document into the frame
  ///
  ///  let destDocument = frame.contentDocument;
  ///  let srcNode = doc.documentElement;
  ///  let newNode = destDocument.importNode(srcNode, true);
  ///
  ///  destDocument.replaceChild(newNode, destDocument.documentElement);
  /// }
  ///  The code in lines 4–12 handle creating the new HTML document and inserting some content
  ///  into it. Line 4 uses createHTMLDocument() to construct a new HTML document
  ///  whose <title> is "New Document". Lines 5 and 6 create a
  ///  new paragraph element with some simple content, and then lines 8–12 handle inserting the
  ///  new paragraph into the new document.
  ///  Line 16 pulls the contentDocument of the frame; this is the document into
  ///  which we'll be injecting the new content. The next two lines handle importing the
  ///  contents of our new document into the new document's context. Finally, line 20 actually
  ///  replaces the contents of the frame with the new document's contents.
  ///
  /// View Live Examples
  /// The returned document is pre-constructed with the following HTML:
  /// <!doctype html>
  /// <html>
  /// <head>
  /// <title>title</title>
  /// </head>
  /// <body>
  /// </body>
  /// </html>
  ///
  Document createHTMLDocument([String? title]) =>
      js_util.callMethod(this, 'createHTMLDocument', [title]);

  ///  Returns a boolean value indicating if a given feature is
  /// supported or not. This function is unreliable and kept for
  /// compatibility purpose alone: except for SVG-related queries, it
  /// always returns [true]. Old browsers are very inconsistent in
  /// their behavior.
  ///
  /// const flag = document.implementation.hasFeature(feature, version);
  ///
  bool hasFeature() => js_util.callMethod(this, 'hasFeature', []);
}

/// The interface represents a [Node] containing a doctype.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    DocumentType
///
///
@JS()
@staticInterop
class DocumentType implements Node, ChildNode {
  external DocumentType();
}

extension PropsDocumentType on DocumentType {
  /// A [DOMString], eg ["html"] for [<!DOCTYPE HTML>].
  ///
  String get name => js_util.getProperty(this, 'name');

  ///  A [DOMString], eg ["-//W3C//DTD HTML 4.01//EN"], empty string
  /// for HTML5.
  ///
  String get publicId => js_util.getProperty(this, 'publicId');

  ///  A [DOMString], eg ["http://www.w3.org/TR/html4/strict.dtd"],
  /// empty string for HTML5.
  ///
  String get systemId => js_util.getProperty(this, 'systemId');
}

///  The interface represents a minimal document object that has no
/// parent.
///  It is used as a lightweight version of [Document] that stores a
/// segment of a document structure comprised of nodes just like a
/// standard document. The key difference is due to the fact that the
/// document fragment isn't part of the active document tree
/// structure. Changes made to the fragment don't affect the document
/// (even on reflow) or incur any performance impact when changes are
/// made.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    DocumentFragment
///
///
@JS()
@staticInterop
class DocumentFragment implements Node, NonElementParentNode, ParentNode {
  external DocumentFragment();
}

///  The interface of the Shadow DOM API is the root node of a DOM
/// subtree that is rendered separately from a document's main DOM
/// tree.
///  You can retrieve a reference to an element's shadow root using
/// its [Element.shadowRoot] property, provided it was created using
/// [Element.attachShadow()] with the [mode] option set to [open].
@JS()
@staticInterop
class ShadowRoot implements DocumentFragment, DocumentOrShadowRoot, InnerHTML {
  external ShadowRoot();
}

extension PropsShadowRoot on ShadowRoot {
  ///
  ///    The mode of the [ShadowRoot] — either [open] or [closed].
  ///     This defines whether or not the shadow root's internal
  /// features are accessible from JavaScript.
  ///
  ///
  ShadowRootMode get mode => js_util.getProperty(this, 'mode');

  ///  Returns a boolean that indicates whether was set when the shadow
  /// was attached (see [Element.attachShadow()]).
  ///
  @deprecated
  bool get delegatesFocus => js_util.getProperty(this, 'delegatesFocus');
  SlotAssignmentMode get slotAssignment =>
      js_util.getProperty(this, 'slotAssignment');

  ///  Returns a reference to the DOM element the [ShadowRoot] is
  /// attached to.
  ///
  Element get host => js_util.getProperty(this, 'host');
  EventHandlerNonNull? get onslotchange =>
      js_util.getProperty(this, 'onslotchange');
  set onslotchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onslotchange', newValue);
  }
}

enum ShadowRootMode { open, closed }

enum SlotAssignmentMode { manual, named }

///   is the most general base class from which all element objects
/// (i.e. objects that represent elements) in a [Document] inherit.
/// It only has methods and properties common to all kinds of
/// elements. More specific classes inherit from .
///  For example, the [HTMLElement] interface is the base interface
/// for HTML elements, while the [SVGElement] interface is the basis
/// for all SVG elements. Most functionality is specified further
/// down the class hierarchy.
///  Languages outside the realm of the Web platform, like XUL
/// through the [XULElement] interface, also implement .
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Element
///
///
@JS()
@staticInterop
class Element
    implements
        Node,
        Animatable,
        ARIAMixin,
        GeometryUtils,
        Region,
        ParentNode,
        NonDocumentTypeChildNode,
        ChildNode,
        Slottable,
        InnerHTML {
  external Element();
}

extension PropsElement on Element {
  ///  The namespace URI of the element, or [null] if it is no
  /// namespace.
  ///
  ///     Note: In Firefox 3.5 and earlier, HTML elements are in no
  /// namespace. In later versions, HTML elements are in the
  /// [http://www.w3.org/1999/xhtml] namespace in both HTML and XML
  /// trees.
  ///
  ///
  String? get namespaceURI => js_util.getProperty(this, 'namespaceURI');

  ///  A [DOMString] representing the namespace prefix of the element,
  /// or [null] if no prefix is specified.
  ///
  String? get prefix => js_util.getProperty(this, 'prefix');

  ///  A [DOMString] representing the local part of the qualified name
  /// of the element.
  ///
  String get localName => js_util.getProperty(this, 'localName');

  ///  Returns a [String] with the name of the tag for the given
  /// element.
  ///
  String get tagName => js_util.getProperty(this, 'tagName');

  /// Is a [DOMString] representing the id of the element.
  ///
  String get id => js_util.getProperty(this, 'id');
  set id(String newValue) {
    js_util.setProperty(this, 'id', newValue);
  }

  /// Is a [DOMString] representing the class of the element.
  ///
  dynamic get className => js_util.getProperty(this, 'className');
  set className(dynamic newValue) {
    js_util.setProperty(this, 'className', newValue);
  }

  ///  Returns a [DOMTokenList] containing the list of class
  /// attributes.
  ///
  DOMTokenList get classList => js_util.getProperty(this, 'classList');

  ///  Returns the name of the shadow DOM slot the element is inserted
  /// in.
  ///
  @experimental
  String get slot => js_util.getProperty(this, 'slot');
  set slot(String newValue) {
    js_util.setProperty(this, 'slot', newValue);
  }

  ///  Returns a boolean value indicating if the element has one or
  /// more HTML attributes present.
  ///
  /// var result = element.hasAttributes();
  ///
  bool hasAttributes() => js_util.callMethod(this, 'hasAttributes', []);

  ///  Returns a [NamedNodeMap] object containing the assigned
  /// attributes of the corresponding HTML element.
  ///
  NamedNodeMap get attributes => js_util.getProperty(this, 'attributes');

  /// Returns an array of attribute names from the current element.
  ///
  /// let attributeNames = element.getAttributeNames();
  ///
  /// The following example shows how:
  ///
  ///  For an attribute which has a namespace prefix, getAttributeNames() returns that namespace prefix along with the attribute name.
  ///  For an attribute which has no namespace prefix, getAttributeNames() returns just the attribute name, as-is.
  ///
  /// It’s important to understand that:
  ///
  ///  An attribute can be present in the DOM with a namespace but lacking a namespace prefix.
  ///  For an attribute in the DOM that has a namespace but lacks a namespace prefix, getAttributeNames() will return just the attribute name, with no indication that the attribute is in a namespace.
  ///
  /// The example below includes such a “namespaced but without a namespace prefix” case.
  /// const element = document.createElement('a')
  ///
  /// // set "href" attribute with no namespace and no namespace prefix
  /// element.setAttribute('href', 'https://example.com')
  /// // set "href" attribute with namespace and also "xlink" namespace prefix
  /// element.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', 'https://example.com')
  /// // set "show" attribute with namespace but no namespace prefix
  /// element.setAttributeNS('http://www.w3.org/1999/xlink', 'show', 'new')
  ///
  /// // Iterate over element's attributes
  /// for (let name of element.getAttributeNames()) {
  ///  let value = element.getAttribute(name);
  ///  console.log(name, value);
  /// }
  ///
  /// // logs:
  /// // href https://example.com
  /// // xlink:href https://example.com
  /// // show new
  ///
  Iterable<String> getAttributeNames() =>
      js_util.callMethod(this, 'getAttributeNames', []);

  ///  Retrieves the value of the named attribute from the current node
  /// and returns it as a string.
  ///
  /// let attribute = element.getAttribute(attributeName);
  ///
  /// where
  ///
  ///
  ///   attribute is a string containing the value of
  ///   attributeName.
  ///
  ///
  ///   attributeName is the name of the attribute whose value you
  ///   want to get.
  ///
  ///
  String? getAttribute(String qualifiedName) =>
      js_util.callMethod(this, 'getAttribute', [qualifiedName]);

  ///  Retrieves the value of the attribute with the specified
  /// namespace and name from the current node and returns it as a
  /// string.
  ///
  /// attrVal = element.getAttributeNS(namespace, name)
  ///
  String? getAttributeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'getAttributeNS', [namespace, localName]);

  /// Sets the value of a named attribute of the current node.
  ///
  /// Element.setAttribute(name, value);
  ///
  ///
  ///  In the following example, setAttribute() is used to set attributes on a
  ///  <button>.
  ///
  /// <button>Hello World</button>
  ///
  /// ```
  ///
  /// var b = document.querySelector("button");
  ///
  /// b.setAttribute("name", "helloButton");
  /// b.setAttribute("disabled", "");
  ///
  /// ```
  ///
  /// This demonstrates two things:
  ///
  ///
  ///   The first call to setAttribute() above shows changing the name attribute's value to "helloButton".
  ///   You can see this using your browser's page inspector (Chrome,
  ///   Edge,
  ///   Firefox, Safari).
  ///
  ///
  ///   To set the value of a Boolean attribute, such as disabled, you can specify any value.
  ///   An empty string or the name of the attribute are recommended values.
  ///   All that matters is that if the attribute is present at all, regardless of its actual value, its value is considered to be true.
  ///   The absence of the attribute means its value is false. By setting the value of the disabled attribute to the empty string (""), we are setting disabled to true, which results in the button being disabled.
  ///
  ///
  /// DOM methods dealing with element's attributes:
  ///
  /// Not namespace-aware, most commonly used methods
  /// Namespace-aware variants (DOM Level 2)
  /// DOM Level 1 methods for dealing with Attr nodes directly (seldom used)
  /// DOM Level 2 namespace-aware methods for dealing with Attr nodes directly (seldom used)
  ///
  ///
  /// setAttribute (DOM 1)
  /// setAttributeNS
  /// setAttributeNode
  /// setAttributeNodeNS
  /// getAttribute (DOM 1)
  /// getAttributeNS
  /// getAttributeNode
  /// getAttributeNodeNS
  /// hasAttribute (DOM 2)
  /// hasAttributeNS
  /// -
  /// -
  /// removeAttribute (DOM 1)
  /// removeAttributeNS
  /// removeAttributeNode
  /// -
  ///
  Object setAttribute(String qualifiedName, String value) =>
      js_util.callMethod(this, 'setAttribute', [qualifiedName, value]);

  ///  Sets the value of the attribute with the specified name and
  /// namespace, from the current node.
  ///
  /// element.setAttributeNS(namespace, name, value)
  ///  namespace is a string specifying the namespace of the attribute.
  ///
  ///   name is a string identifying the attribute by its qualified name;
  ///   that is, a namespace prefix followed by a colon followed by a local name.
  ///
  ///  value is the desired string value of the new attribute.
  ///
  /// let d = document.getElementById('d1');
  /// d.setAttributeNS('http://www.mozilla.org/ns/specialspace', 'spec:align', 'center');
  ///
  Object setAttributeNS(
          String? namespace, String qualifiedName, String value) =>
      js_util.callMethod(
          this, 'setAttributeNS', [namespace, qualifiedName, value]);

  /// Removes the named attribute from the current node.
  ///
  /// element.removeAttribute(attrName);
  ///
  /// // Given: <div id="div1" align="left" width="200px">
  /// document.getElementById("div1").removeAttribute("align");
  /// // Now: <div id="div1" width="200px">
  ///
  Object removeAttribute(String qualifiedName) =>
      js_util.callMethod(this, 'removeAttribute', [qualifiedName]);

  ///  Removes the attribute with the specified name and namespace,
  /// from the current node.
  ///
  /// element.removeAttributeNS(namespace, attrName);
  ///
  /// // Given:
  /// //  <div id="div1" xmlns:special="http://www.mozilla.org/ns/specialspace"
  /// //   special:specialAlign="utterleft" width="200px" />
  /// d = document.getElementById("div1");
  /// d.removeAttributeNS("http://www.mozilla.org/ns/specialspace", "specialAlign");
  /// // Now: <div id="div1" width="200px" />
  ///
  Object removeAttributeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'removeAttributeNS', [namespace, localName]);

  ///  Toggles a boolean attribute, removing it if it is present and
  /// adding it if it is not present, on the specified element.
  ///
  /// toggleAttribute(name);
  /// toggleAttribute(name, force);
  ///
  ///
  ///  In the following example, toggleAttribute() is used to toggle the
  ///  disabled attribute of an <input>.
  ///
  /// <input value="text">
  /// <button>toggleAttribute("disabled")</button>
  ///
  /// ```
  ///
  /// var button = document.querySelector("button");
  /// var input = document.querySelector("input");
  ///
  /// button.addEventListener("click", function(){
  ///  input.toggleAttribute("disabled");
  /// });
  ///
  /// ```
  ///
  bool toggleAttribute(String qualifiedName, [bool? force]) =>
      js_util.callMethod(this, 'toggleAttribute', [qualifiedName, force]);

  ///  Returns a boolean value indicating if the element has the
  /// specified attribute or not.
  ///
  /// var result = element.hasAttribute(name);
  ///  result
  ///
  ///   holds the return value true or false.
  ///
  ///  name
  ///
  ///   is a string representing the name of the attribute.
  ///
  ///
  /// var foo = document.getElementById("foo");
  /// if (foo.hasAttribute("bar")) {
  ///   // do something
  /// }
  ///
  bool hasAttribute(String qualifiedName) =>
      js_util.callMethod(this, 'hasAttribute', [qualifiedName]);

  ///  Returns a boolean value indicating if the element has the
  /// specified attribute, in the specified namespace, or not.
  ///
  /// result = element.hasAttributeNS(namespace,localName)
  ///  result is the boolean value true or false.
  ///  namespace is a string specifying the namespace of the attribute.
  ///  localName is the name of the attribute.
  ///
  /// // Check that the attribute exists before you set a value
  /// var d = document.getElementById("div1");
  /// if (d.hasAttributeNS(
  ///     "http://www.mozilla.org/ns/specialspace/",
  ///     "special-align")) {
  ///  d.setAttribute("align", "center");
  /// }
  ///
  bool hasAttributeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'hasAttributeNS', [namespace, localName]);

  ///  Retrieves the node representation of the named attribute from
  /// the current node and returns it as an [Attr].
  ///
  /// var attrNode = element.getAttributeNode(attrName);
  ///  attrNode is an Attr node for the attribute.
  ///  attrName is a string containing the name of the attribute.
  ///
  /// // html: <div id="top" />
  /// let t = document.getElementById("top");
  /// let idAttr = t.getAttributeNode("id");
  /// alert(idAttr.value == "top")
  ///
  Attr? getAttributeNode(String qualifiedName) =>
      js_util.callMethod(this, 'getAttributeNode', [qualifiedName]);

  ///  Retrieves the node representation of the attribute with the
  /// specified name and namespace, from the current node and returns
  /// it as an [Attr].
  ///
  /// attributeNode = element.getAttributeNodeNS(namespace, nodeName)
  ///  attributeNode is the node for specified attribute.
  ///  namespace is a string specifying the namespace of the attribute.
  ///  nodeName is a string specifying the name of the attribute.
  ///
  Attr? getAttributeNodeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'getAttributeNodeNS', [namespace, localName]);

  ///  Sets the node representation of the named attribute from the
  /// current node.
  ///
  /// var replacedAttr = element.setAttributeNode(attribute);
  ///  attribute is the Attr node to set on the element.
  ///
  ///   replacedAttr is the replaced attribute node, if any, returned by this
  ///   function.
  ///
  ///
  /// This example copies the align attribute from one element to another.
  /// <div id="one" align="left">one</div>
  /// <div id="two">two</div>
  ///
  /// ```
  ///
  /// let d1 = document.getElementById('one');
  /// let d2 = document.getElementById('two');
  /// let a = d1.getAttributeNode('align');
  ///
  /// d2.setAttributeNode(a.cloneNode(true));
  ///
  /// // Returns: 'left'
  /// alert(d2.attributes[1].value);
  ///
  /// ```
  ///
  Attr? setAttributeNode(Attr attr) =>
      js_util.callMethod(this, 'setAttributeNode', [attr]);

  ///  Sets the node representation of the attribute with the specified
  /// name and namespace, from the current node.
  ///
  /// replacedAttr = element.setAttributeNodeNS(attributeNode)
  ///  replacedAttr is the replaced attribute node, if any, returned by this function.
  ///  attributeNode is an Attr node.
  ///
  /// // <div id="one" xmlns:myNS="http://www.mozilla.org/ns/specialspace"
  /// //      myNS:special-align="utterleft">one</div>
  /// // <div id="two">two</div>
  ///
  /// var myns = "http://www.mozilla.org/ns/specialspace";
  /// var d1 = document.getElementById("one");
  /// var d2 = document.getElementById("two");
  /// var a = d1.getAttributeNodeNS(myns, "special-align");
  /// d2.setAttributeNodeNS(a.cloneNode(true));
  /// alert(d2.attributes[1].value) // returns: `utterleft'
  ///
  Attr? setAttributeNodeNS(Attr attr) =>
      js_util.callMethod(this, 'setAttributeNodeNS', [attr]);

  ///  Removes the node representation of the named attribute from the
  /// current node.
  ///
  /// removedAttr = element.removeAttributeNode(attributeNode)
  ///  attributeNode is the Attr node that needs to be removed.
  ///  removedAttr is the removed Attr node.
  ///
  /// // Given: <div id="top" align="center" />
  /// var d = document.getElementById("top");
  /// var d_align = d.getAttributeNode("align");
  /// d.removeAttributeNode(d_align);
  /// // align is now removed: <div id="top" />
  ///
  Attr removeAttributeNode(Attr attr) =>
      js_util.callMethod(this, 'removeAttributeNode', [attr]);

  ///  Attaches a shadow DOM tree to the specified element and returns
  /// a reference to its [ShadowRoot].
  ///
  /// attachShadow(init)
  ///
  ShadowRoot attachShadow(ShadowRootInit init) =>
      js_util.callMethod(this, 'attachShadow', [init]);

  ///  Returns the open shadow root that is hosted by the element, or
  /// null if no open shadow root is present.
  ///
  ShadowRoot? get shadowRoot => js_util.getProperty(this, 'shadowRoot');

  ///  Returns the [Element] which is the closest ancestor of the
  /// current element (or the current element itself) which matches the
  /// selectors given in parameter.
  ///
  /// var closestElement = targetElement.closest(selectors);
  ///
  Element? closest(String selectors) =>
      js_util.callMethod(this, 'closest', [selectors]);

  ///  Returns a boolean value indicating whether or not the element
  /// would be selected by the specified selector string.
  ///
  /// var result = element.matches(selectorString);
  ///
  /// <ul id="birds">
  ///  <li>Orange-winged parrot</li>
  ///  <li class="endangered">Philippine eagle</li>
  ///  <li>Great white pelican</li>
  /// </ul>
  ///
  /// <script type="text/javascript">
  ///  var birds = document.getElementsByTagName('li');
  ///
  ///  for (var i = 0; i < birds.length; i++) {
  ///   if (birds[i].matches('.endangered')) {
  ///    console.log('The ' + birds[i].textContent + ' is endangered!');
  ///   }
  ///  }
  /// </script>
  ///  This will log "The Philippine eagle is endangered!" to the console, since the element
  ///  has indeed a class attribute with value endangered.
  ///
  bool matches(String selectors) =>
      js_util.callMethod(this, 'matches', [selectors]);

  bool webkitMatchesSelector(String selectors) =>
      js_util.callMethod(this, 'webkitMatchesSelector', [selectors]);

  ///  Returns a live [HTMLCollection] containing all descendant
  /// elements, of a particular tag name, from the current element.
  ///
  /// elements = element.getElementsByTagName(tagName)
  ///
  ///   elements is a live HTMLCollection of elements
  ///   with a matching tag name, in the order they appear. If no elements are found, the
  ///   HTMLCollection is empty.
  ///
  ///
  ///   element is the element from where the search starts. Only the
  ///   element's descendants are included, not the element itself.
  ///
  ///
  ///   tagName is the qualified name to look for. The special string
  ///   "*" represents all elements. For compatibility with XHTML, lower-case
  ///   should be used.
  ///
  ///
  /// // Check the status of each data cell in a table
  /// const table = document.getElementById('forecast-table');
  /// const cells = table.getElementsByTagName('td');
  ///
  /// for (let cell of cells) {
  ///  let status = cell.getAttribute('data-status');
  ///  if (status === 'open') {
  ///   // Grab the data
  ///  }
  /// }
  ///
  HTMLCollection getElementsByTagName(String qualifiedName) =>
      js_util.callMethod(this, 'getElementsByTagName', [qualifiedName]);

  ///  Returns a live [HTMLCollection] containing all descendant
  /// elements, of a particular tag name and namespace, from the
  /// current element.
  ///
  /// elements = element.getElementsByTagNameNS(namespaceURI, localName)
  ///
  ///   elements is a live HTMLCollection of found elements in
  ///   the order they appear in the tree.
  ///
  ///
  ///   element is the element from where the search should start. Note that
  ///   only the descendants of this element are included in the search, not the node itself.
  ///
  ///
  ///   namespaceURI is the namespace URI of elements to look for (see
  ///   Element.namespaceURI and Attr.namespaceURI). For
  ///   example, if you need to look for XHTML elements, use the XHTML namespace URI,
  ///   http://www.w3.org/1999/xhtml.
  ///
  ///
  ///   localName is either the local name of elements to look for or the
  ///   special value "*", which matches all elements (see
  ///   Element.localName and Attr.localName).
  ///
  ///
  /// // check the alignment on a number of cells in a table in an XHTML document.
  /// var table = document.getElementById("forecast-table");
  /// var cells = table.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "td");
  ///
  /// for (var i = 0; i < cells.length; i++) {
  ///   var axis = cells[i].getAttribute("axis");
  ///   if (axis == "year") {
  ///     // grab the data
  ///   }
  /// }
  ///
  HTMLCollection getElementsByTagNameNS(String? namespace, String localName) =>
      js_util
          .callMethod(this, 'getElementsByTagNameNS', [namespace, localName]);

  ///  Returns a live [HTMLCollection] that contains all descendants of
  /// the current element that possess the list of classes given in the
  /// parameter.
  ///
  /// var elements = element.getElementsByClassName(names);
  ///
  HTMLCollection getElementsByClassName(String classNames) =>
      js_util.callMethod(this, 'getElementsByClassName', [classNames]);

  ///  Inserts a given element node at a given position relative to the
  /// element it is invoked upon.
  ///
  /// targetElement.insertAdjacentElement(position, element);
  ///
  /// beforeBtn.addEventListener('click', function() {
  ///  var tempDiv = document.createElement('div');
  ///  tempDiv.style.backgroundColor = randomColor();
  ///  if (activeElem) {
  ///   activeElem.insertAdjacentElement('beforebegin', tempDiv);
  ///  }
  ///  setListener(tempDiv);
  /// });
  ///
  /// afterBtn.addEventListener('click', function() {
  ///  var tempDiv = document.createElement('div');
  ///  tempDiv.style.backgroundColor = randomColor();
  ///  if (activeElem) {
  ///   activeElem.insertAdjacentElement('afterend', tempDiv);
  ///  }
  ///  setListener(tempDiv);
  /// });
  ///  Have a look at our insertAdjacentElement.html
  ///  demo on GitHub (see the source
  /// code too.) Here, we have a sequence of <div> elements inside a
  ///  container. When one is clicked, it becomes selected and you can then press the
  ///  Insert before and Insert after buttons to insert new divs before or
  ///  after the selected element using insertAdjacentElement().
  ///
  Element? insertAdjacentElement(String where, Element element) =>
      js_util.callMethod(this, 'insertAdjacentElement', [where, element]);

  ///  Inserts a given text node at a given position relative to the
  /// element it is invoked upon.
  ///
  /// element.insertAdjacentText(where, data);
  ///
  /// beforeBtn.addEventListener('click', function() {
  ///  para.insertAdjacentText('afterbegin',textInput.value);
  /// });
  ///
  /// afterBtn.addEventListener('click', function() {
  ///  para.insertAdjacentText('beforeend',textInput.value);
  /// });
  ///  Have a look at our insertAdjacentText.html
  ///  demo on GitHub (see the source
  /// code too.) Here we have a simple paragraph. You can enter some text into the form
  ///  element, then press the Insert before and Insert after buttons to
  ///  insert it before or after the existing paragraph text using
  ///  insertAdjacentText(). Note that the existing text node is not added to —
  ///  further text nodes are created containing the new additions.
  ///
  Object insertAdjacentText(String where, String data) =>
      js_util.callMethod(this, 'insertAdjacentText', [where, data]);

  StylePropertyMapReadOnly computedStyleMap() =>
      js_util.callMethod(this, 'computedStyleMap', []);

  DOMRectList getClientRects() =>
      js_util.callMethod(this, 'getClientRects', []);

  DOMRect getBoundingClientRect() =>
      js_util.callMethod(this, 'getBoundingClientRect', []);

  Object scrollIntoView([dynamic arg]) =>
      js_util.callMethod(this, 'scrollIntoView', [arg]);

  Object scroll([/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]) =>
      js_util.callMethod(this, 'scroll', [x, y]);

  Object scrollTo(
          [/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]) =>
      js_util.callMethod(this, 'scrollTo', [x, y]);

  Object scrollBy(
          [/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]) =>
      js_util.callMethod(this, 'scrollBy', [x, y]);

  /* double | NaN */ dynamic get scrollTop =>
      js_util.getProperty(this, 'scrollTop');
  set scrollTop(/* double | NaN */ dynamic newValue) {
    js_util.setProperty(this, 'scrollTop', newValue);
  }

  /* double | NaN */ dynamic get scrollLeft =>
      js_util.getProperty(this, 'scrollLeft');
  set scrollLeft(/* double | NaN */ dynamic newValue) {
    js_util.setProperty(this, 'scrollLeft', newValue);
  }

  int get scrollWidth => js_util.getProperty(this, 'scrollWidth');
  int get scrollHeight => js_util.getProperty(this, 'scrollHeight');
  int get clientTop => js_util.getProperty(this, 'clientTop');
  int get clientLeft => js_util.getProperty(this, 'clientLeft');
  int get clientWidth => js_util.getProperty(this, 'clientWidth');
  int get clientHeight => js_util.getProperty(this, 'clientHeight');
  Object requestPointerLock() =>
      js_util.callMethod(this, 'requestPointerLock', []);

  Future<Object> requestFullscreen([FullscreenOptions? options]) =>
      js_util.promiseToFuture(
          js_util.callMethod(this, 'requestFullscreen', [options]));

  EventHandlerNonNull? get onfullscreenchange =>
      js_util.getProperty(this, 'onfullscreenchange');
  set onfullscreenchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenchange', newValue);
  }

  EventHandlerNonNull? get onfullscreenerror =>
      js_util.getProperty(this, 'onfullscreenerror');
  set onfullscreenerror(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenerror', newValue);
  }

  Object setPointerCapture(int pointerId) =>
      js_util.callMethod(this, 'setPointerCapture', [pointerId]);

  Object releasePointerCapture(int pointerId) =>
      js_util.callMethod(this, 'releasePointerCapture', [pointerId]);

  bool hasPointerCapture(int pointerId) =>
      js_util.callMethod(this, 'hasPointerCapture', [pointerId]);

  CSSPseudoElement? pseudo(String type) =>
      js_util.callMethod(this, 'pseudo', [type]);

  String get outerHTML => js_util.getProperty(this, 'outerHTML');
  set outerHTML(String newValue) {
    js_util.setProperty(this, 'outerHTML', newValue);
  }

  Object insertAdjacentHTML(String position, String text) =>
      js_util.callMethod(this, 'insertAdjacentHTML', [position, text]);

  String get elementTiming => js_util.getProperty(this, 'elementTiming');
  set elementTiming(String newValue) {
    js_util.setProperty(this, 'elementTiming', newValue);
  }

  Node getSpatialNavigationContainer() =>
      js_util.callMethod(this, 'getSpatialNavigationContainer', []);

  Iterable<Node> focusableAreas([FocusableAreasOption? option]) =>
      js_util.callMethod(this, 'focusableAreas', [option]);

  Node? spatialNavigationSearch(SpatialNavigationDirection dir,
          [SpatialNavigationSearchOptions? options]) =>
      js_util.callMethod(this, 'spatialNavigationSearch', [dir, options]);

  @JS('part')
  @staticInterop
  DOMTokenList get mPart => js_util.getProperty(this, 'part');
}

@anonymous
@JS()
@staticInterop
class ShadowRootInit {
  external factory ShadowRootInit(
      {ShadowRootMode mode,
      bool delegatesFocus = false,
      SlotAssignmentMode? slotAssignment = SlotAssignmentMode.named});
}

extension PropsShadowRootInit on ShadowRootInit {
  ShadowRootMode get mode => js_util.getProperty(this, 'mode');
  set mode(ShadowRootMode newValue) {
    js_util.setProperty(this, 'mode', newValue);
  }

  bool get delegatesFocus => js_util.getProperty(this, 'delegatesFocus');
  set delegatesFocus(bool newValue) {
    js_util.setProperty(this, 'delegatesFocus', newValue);
  }

  SlotAssignmentMode get slotAssignment =>
      js_util.getProperty(this, 'slotAssignment');
  set slotAssignment(SlotAssignmentMode newValue) {
    js_util.setProperty(this, 'slotAssignment', newValue);
  }
}

///  The interface represents a collection of [Attr] objects. Objects
/// inside a are not in any particular order, unlike [NodeList],
/// although they may be accessed by an index as in an array.
///  A object is live and will thus be auto-updated if changes are
/// made to its contents internally or elsewhere.
///
///   Note: Although called , this interface doesn't deal with [Node]
/// objects but with [Attr] objects, which were originally a
/// specialized class of [Node], and still are in some
/// implementations.
///
@JS()
@staticInterop
class NamedNodeMap {
  external NamedNodeMap();
}

extension PropsNamedNodeMap on NamedNodeMap {
  /// Returns the amount of objects in the map.
  ///
  int get length => js_util.getProperty(this, 'length');

  ///  Returns the [Attr] at the given index, or [null] if the index is
  /// higher or equal to the number of nodes.
  ///
  Attr? item(int index) => js_util.callMethod(this, 'item', [index]);

  /// Returns a [Attr], corresponding to the given name.
  ///
  /// myAttr = attrs.getNamedItem(name)
  ///
  Attr? getNamedItem(String qualifiedName) =>
      js_util.callMethod(this, 'getNamedItem', [qualifiedName]);

  ///  Returns a [Attr] identified by a namespace and related local
  /// name.
  ///
  Attr? getNamedItemNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'getNamedItemNS', [namespace, localName]);

  ///  Replaces, or adds, the [Attr] identified in the map by the given
  /// name.
  ///
  Attr? setNamedItem(Attr attr) =>
      js_util.callMethod(this, 'setNamedItem', [attr]);

  ///  Replaces, or adds, the [Attr] identified in the map by the given
  /// namespace and related local name.
  ///
  Attr? setNamedItemNS(Attr attr) =>
      js_util.callMethod(this, 'setNamedItemNS', [attr]);

  /// Removes the [Attr] identified by the given map.
  ///
  Attr removeNamedItem(String qualifiedName) =>
      js_util.callMethod(this, 'removeNamedItem', [qualifiedName]);

  ///  Removes the [Attr] identified by the given namespace and related
  /// local name.
  ///
  Attr removeNamedItemNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'removeNamedItemNS', [namespace, localName]);
}

///  The interface represents one of an element's attributes as an
/// object. In most situations, you will directly retrieve the
/// attribute value as a string (e.g., [Element.getAttribute()]), but
/// certain functions (e.g., [Element.getAttributeNode()]) or means
/// of iterating return instances.
///  The core idea of an object of type is the association between a
/// name and a value. An attribute may also be part of a namespace
/// and, in this case, it also has a URI identifying the namespace,
/// and a prefix that is an abbreviation for the namespace.
///  The name is deemed local when it ignores the eventual namespace
/// prefix and deemed qualified when it includes the prefix of the
/// namespace, if any, separated from the local name by a colon
/// ([:]). We have three cases: an attribute outside of a namespace,
/// an attribute inside a namespace without a prefix defined, an
/// attribute inside a namespace with a prefix:
///
///
///
///    Attribute
///    Namespace name
///    Namespace prefix
///    Attribute local name
///    Attribute qualified name
///
///
///
///
///    [myAttr]
///    none
///    none
///    [myAttr]
///    [myAttr]
///
///
///    [myAttr]
///    [mynamespace]
///    none
///    [myAttr]
///    [myAttr]
///
///
///    [myAttr]
///    [mynamespace]
///    [myns]
///    [myAttr]
///    [myns:myAttr]
///
///
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Attr
///
///
///
///   Note: This interface represents only attributes present in the
/// tree representation of the [Element], being a SVG, an HTML or a
/// MathML element. It doesn't represent the property of an interface
/// associated with such element, such as [HTMLTableElement] for a
/// [<table>] element. (See this article for more information about
/// attributes and how they are reflected into properties.)
///
@JS()
@staticInterop
class Attr implements Node {
  external Attr();
}

extension PropsAttr on Attr {
  ///  A [String] representing the URI of the namespace of the
  /// attribute, or [null] if there is no namespace.
  ///
  String? get namespaceURI => js_util.getProperty(this, 'namespaceURI');

  ///  A [String] representing the namespace prefix of the attribute,
  /// or [null] if a namespace without prefix or no namespace are
  /// specified.
  ///
  String? get prefix => js_util.getProperty(this, 'prefix');

  ///  A [String] representing the local part of the qualified name of
  /// the attribute.
  ///
  String get localName => js_util.getProperty(this, 'localName');

  ///  The attribute's qualified name. If the attribute is not in a
  /// namespace, it will be the same as [localName] property.
  ///
  String get name => js_util.getProperty(this, 'name');

  ///  The attribute's value, a string that can be set and get using
  /// this property.
  ///
  String get value => js_util.getProperty(this, 'value');
  set value(String newValue) {
    js_util.setProperty(this, 'value', newValue);
  }

  /// The [Element] the attribute belongs to.
  ///
  Element? get ownerElement => js_util.getProperty(this, 'ownerElement');

  /// This property always returns [true].
  ///
  @deprecated
  bool get specified => js_util.getProperty(this, 'specified');
}

///  The abstract interface represents a [Node] object that contains
/// characters. This is an abstract interface, meaning there aren't
/// any objects of type : it is implemented by other interfaces like
/// [Text], [Comment], [CDATASection], or [ProcessingInstruction],
/// which aren't abstract.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
@JS()
@staticInterop
class CharacterData implements Node, NonDocumentTypeChildNode, ChildNode {
  external CharacterData();
}

extension PropsCharacterData on CharacterData {
  ///  Is a string representing the textual data contained in this
  /// object.
  ///
  String get data => js_util.getProperty(this, 'data');
  set data(String newValue) {
    js_util.setProperty(this, 'data', newValue);
  }

  ///  Returns a number representing the size of the string contained
  /// in the object.
  ///
  int get length => js_util.getProperty(this, 'length');

  ///  Returns a [String] containing the part of [CharacterData.data]
  /// of the specified length and starting at the specified offset.
  ///
  ///  domString = characterData.substringData(offset, count)
  ///
  String substringData(int offset, int count) =>
      js_util.callMethod(this, 'substringData', [offset, count]);

  ///  Appends the given string to the [CharacterData.data] string;
  /// when this method returns, [data] contains the concatenated
  /// [DOMString].
  ///
  /// appendData(data);
  ///
  /// <span>Result: </span>A text
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.appendData(" - appended text.");
  ///
  Object appendData(String data) =>
      js_util.callMethod(this, 'appendData', [data]);

  ///  Inserts the specified characters, at the specified offset, in
  /// the [CharacterData.data] string; when this method returns, [data]
  /// contains the modified [DOMString].
  ///
  /// characterData.insertData(offset, data)
  ///
  /// <span>Result: </span>A string.
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.insertData(2, "long ");
  ///
  Object insertData(int offset, String data) =>
      js_util.callMethod(this, 'insertData', [offset, data]);

  ///  Removes the specified amount of characters, starting at the
  /// specified offset, from the [CharacterData.data] string; when this
  /// method returns, [data] contains the shortened string.
  ///
  /// characterData.deleteData(offset, count)
  ///
  /// <span>Result: </span>A long string.
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.deleteData(1, 5);
  ///
  Object deleteData(int offset, int count) =>
      js_util.callMethod(this, 'deleteData', [offset, count]);

  ///  Replaces the specified amount of characters, starting at the
  /// specified offset, with the specified [DOMString]; when this
  /// method returns, [data] contains the modified string.
  ///
  /// characterData.replaceData(offset, count, data)
  ///
  /// <span>Result: </span>A long string.
  ///
  /// let span = document.getElementsByTagName("span")[0];
  /// let textnode = span.nextSibling;
  ///
  /// textnode.replaceData(2, 4, "replaced");
  ///
  Object replaceData(int offset, int count, String data) =>
      js_util.callMethod(this, 'replaceData', [offset, count, data]);
}

/// The interface represents a text [node] in a DOM tree.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Text
///
///
///  To understand what a text node is, consider the following
/// document:
/// [<html class="e"><head><title>Aliens?</title></head>
///  <body>Why yes.
/// </body></html>
/// ]
///  In that document, there are three text nodes, with the following
/// contents:
///
///  "[Aliens?]" (the contents of the [title] element)
///   "[\n]" (after the [</head>] end tag, a newline followed by a
/// space)
///  "[Why yes.\n]" (the contents of the [body] element)
///
///  Each of those text nodes is an object that has the properties
/// and methods documented in this article.
@JS()
@staticInterop
class Text implements CharacterData, GeometryUtils, Slottable {
  external Text([String? data = '']);
}

extension PropsText on Text {
  /// Breaks the node into two nodes at a specified offset.
  ///
  /// newNode = textNode.splitText(offset)
  ///
  ///
  ///  In this example, the text of a <p> is split into two text nodes, and a
  ///  <u> is inserted between them.
  ///
  /// <p>foobar</p>
  ///
  /// const p = document.querySelector('p');
  ///
  /// // Get contents of <p> as a text node
  /// const foobar = p.firstChild;
  ///
  /// // Split 'foobar' into two text nodes, 'foo' and 'bar',
  /// // and save 'bar' as a const
  /// const bar = foobar.splitText(3);
  ///
  /// // Create a <u> element containing ' new content '
  /// const u = document.createElement('u');
  /// u.appendChild(document.createTextNode(' new content '));
  ///
  /// // Add <u> before 'bar'
  /// p.insertBefore(u, bar);
  ///
  /// // The result is: <p>foo<u> new content </u>bar</p>
  ///
  Text splitText(int offset) => js_util.callMethod(this, 'splitText', [offset]);

  ///  Returns a [DOMString] containing the text of all [Text] nodes
  /// logically adjacent to this [Node], concatenated in document
  /// order.
  ///
  String get wholeText => js_util.getProperty(this, 'wholeText');
}

///
///  The interface represents a CDATA section
///   that can be used within XML to include extended portions of
/// unescaped text.
///   When inside a CDATA section, the symbols [<] and [&] don't need
/// escaping
///  as they normally do.
///
/// In XML, a CDATA section looks like:
/// [<![CDATA[ ... ]]>
/// ]
/// For example:
///  [<foo>Here is a CDATA section: <![CDATA[ < > & ]]> with all
/// kinds of unescaped text.</foo>
/// ]
///
///   The only sequence which is not allowed within a CDATA section
/// is the closing sequence
///  of a CDATA section itself, []]>].
///   *Note: CDATA sections should not be used within HTML they are
/// considered as comments and not displayed.
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Text
///
///
///
///
///
///    CDATASection
///
///
@JS()
@staticInterop
class CDATASection implements Text {
  external CDATASection();
}

///  The interface represents a processing instruction; that is, a
/// [Node] which embeds an instruction targeting a specific
/// application but that can be ignored by any other applications
/// which don't recognize the instruction.
///
///   Warning: nodes are only supported in XML documents, not in HTML
/// documents. In these, a process instruction will be considered as
/// a comment and be represented as a [Comment] object in the tree.
///
///  A processing instruction may be different than the XML
/// declaration.
///
///   Note: User-defined processing instructions cannot begin with
/// "[xml]", as [xml]-prefixed processing-instruction target names
/// are reserved by the XML specification for particular, standard
/// uses (see, for example, [<?xml-stylesheet ?>].
///
/// For example:
/// [<?xml version="1.0"?>
/// ]
/// is a processing instruction whose [target]is [xml].
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    ProcessingInstruction
///
///
@JS()
@staticInterop
class ProcessingInstruction implements CharacterData, LinkStyle {
  external ProcessingInstruction();
}

extension PropsProcessingInstruction on ProcessingInstruction {
  ///  A name identifying the application to which the instruction is
  /// targeted.
  ///
  String get target => js_util.getProperty(this, 'target');
}

///  The interface represents textual notations within markup;
/// although it is generally not visually shown, such comments are
/// available to be read in the source view.
///  Comments are represented in HTML and XML as content between
/// '[<!--]' and '[-->]'. In XML, like inside SVG or MathML markup,
/// the character sequence '[--]' cannot be used within a comment.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Comment
///
///
@JS()
@staticInterop
class Comment implements CharacterData {
  external Comment([String? data = '']);
}

///  The abstract interface is the base class upon which all DOM
/// range types are defined. A range is an object that indicates the
/// start and end points of a section of content within the document.
///  As an abstract interface, you will not directly instantiate an
/// object of type . Instead, you will use the [Range] or
/// [StaticRange] interfaces. To understand the difference between
/// those two interfaces, and how to choose which is appropriate for
/// your needs.
@JS()
@staticInterop
class AbstractRange {
  external AbstractRange();
}

extension PropsAbstractRange on AbstractRange {
  ///  The DOM [Node] in which the beginning of the range, as specified
  /// by the [startOffset] property, is located.
  ///
  Node get startContainer => js_util.getProperty(this, 'startContainer');

  ///  An integer value indicating the offset, in characters, from the
  /// beginning of the node's contents to the last character of the
  /// contents referred to by the range object. This value must be less
  /// than the length of the node indicated in [startContainer].
  ///
  int get startOffset => js_util.getProperty(this, 'startOffset');

  ///  The DOM [Node] in which the end of the range, as specified by
  /// the [endOffset] property, is located.
  ///
  Node get endContainer => js_util.getProperty(this, 'endContainer');

  ///  An integer value indicating the offset, in characters, from the
  /// beginning of the node's contents to the beginning of the range
  /// represented by the range object. This value must be less than the
  /// length of the [endContainer] node.
  ///
  int get endOffset => js_util.getProperty(this, 'endOffset');

  ///  A Boolean value which is [true] if the range is collapsed. A
  /// collapsed range is one whose start position and end position are
  /// the same, resulting in a zero-character-long range.
  ///
  bool get collapsed => js_util.getProperty(this, 'collapsed');
}

@anonymous
@JS()
@staticInterop
class StaticRangeInit {
  external factory StaticRangeInit(
      {Node startContainer, int startOffset, Node endContainer, int endOffset});
}

extension PropsStaticRangeInit on StaticRangeInit {
  Node get startContainer => js_util.getProperty(this, 'startContainer');
  set startContainer(Node newValue) {
    js_util.setProperty(this, 'startContainer', newValue);
  }

  int get startOffset => js_util.getProperty(this, 'startOffset');
  set startOffset(int newValue) {
    js_util.setProperty(this, 'startOffset', newValue);
  }

  Node get endContainer => js_util.getProperty(this, 'endContainer');
  set endContainer(Node newValue) {
    js_util.setProperty(this, 'endContainer', newValue);
  }

  int get endOffset => js_util.getProperty(this, 'endOffset');
  set endOffset(int newValue) {
    js_util.setProperty(this, 'endOffset', newValue);
  }
}

///  The DOM interface extends [AbstractRange] to provide a method to
/// specify a range of content in the DOM whose contents don't update
/// to reflect changes which occur within the DOM tree.
///  This interface offers the same set of properties and methods as
/// [AbstractRange].
/// [AbstractRange] and are not available from web workers.
///
///
///
///    AbstractRange
///
///
///
///
///
///    StaticRange
///
///
@JS()
@staticInterop
class StaticRange implements AbstractRange {
  external StaticRange(StaticRangeInit init);
}

///  The interface represents a fragment of a document that can
/// contain nodes and parts of text nodes.
///  A range can be created by using the [Document.createRange()]
/// method. Range objects can also be retrieved by using the
/// [getRangeAt()] method of the [Selection] object or the
/// [caretRangeFromPoint()] method of the [Document] object.
/// There also is the [Range()] constructor available.
@JS()
@staticInterop
class Range implements AbstractRange {
  external static int get START_TO_START;
  external static int get START_TO_END;
  external static int get END_TO_END;
  external static int get END_TO_START;
  external Range();
}

extension PropsRange on Range {
  ///  Returns the deepest [Node] that contains the [startContainer]
  /// and [endContainer] nodes.
  ///
  Node get commonAncestorContainer =>
      js_util.getProperty(this, 'commonAncestorContainer');

  /// Sets the start position of a [Range].
  ///
  /// range.setStart(startNode, startOffset);
  ///
  Object setStart(Node node, int offset) =>
      js_util.callMethod(this, 'setStart', [node, offset]);

  /// Sets the end position of a [Range].
  ///
  /// range.setEnd(endNode, endOffset);
  ///
  /// const range = document.createRange();
  /// const endNode = document.getElementsByTagName('p').item(3);
  /// const endOffset = endNode.childNodes.length;
  /// range.setEnd(endNode, endOffset);
  ///
  ///   Note: setEnd() is commonly used in conjunction with
  ///   setStart() to fully configure a range.
  ///
  ///
  Object setEnd(Node node, int offset) =>
      js_util.callMethod(this, 'setEnd', [node, offset]);

  /// Sets the start position of a [Range] relative to another [Node].
  ///
  /// range.setStartBefore(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName("div").item(0);
  ///
  /// range.setStartBefore(referenceNode);
  ///
  Object setStartBefore(Node node) =>
      js_util.callMethod(this, 'setStartBefore', [node]);

  /// Sets the start position of a [Range] relative to another [Node].
  ///
  /// range.setStartAfter(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName("div").item(0);
  ///
  /// range.setStartAfter(referenceNode);
  ///
  Object setStartAfter(Node node) =>
      js_util.callMethod(this, 'setStartAfter', [node]);

  /// Sets the end position of a [Range] relative to another [Node].
  ///
  /// range.setEndBefore(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName("div").item(0);
  ///
  /// range.setEndBefore(referenceNode);
  ///
  Object setEndBefore(Node node) =>
      js_util.callMethod(this, 'setEndBefore', [node]);

  /// Sets the end position of a [Range] relative to another [Node].
  ///
  /// range.setEndAfter(referenceNode);
  ///
  /// var range = document.createRange();
  /// var referenceNode = document.getElementsByTagName('div').item(0);
  ///
  /// range.setEndAfter(referenceNode);
  ///
  Object setEndAfter(Node node) =>
      js_util.callMethod(this, 'setEndAfter', [node]);

  /// Collapses the [Range] to one of its boundary points.
  ///
  /// range.collapse(toStart);
  ///
  /// var range = document.createRange();
  ///
  /// referenceNode = document.getElementsByTagName("div").item(0);
  /// range.selectNode(referenceNode);
  /// range.collapse(true);
  ///
  Object collapse([bool? toStart = false]) =>
      js_util.callMethod(this, 'collapse', [toStart]);

  /// Sets the [Range] to contain the [Node] and its contents.
  ///
  /// range.selectNode(referenceNode);
  ///
  /// let range = document.createRange();
  /// let referenceNode = document.getElementsByTagName('div').item(0);
  ///
  /// range.selectNode(referenceNode);
  ///
  Object selectNode(Node node) =>
      js_util.callMethod(this, 'selectNode', [node]);

  /// Sets the [Range] to contain the contents of a [Node].
  ///
  /// range.selectNodeContents(referenceNode);
  ///
  /// range = document.createRange();
  /// referenceNode = document.getElementsByTagName("div")[0];
  /// range.selectNodeContents(referenceNode);
  ///
  Object selectNodeContents(Node node) =>
      js_util.callMethod(this, 'selectNodeContents', [node]);

  ///  Compares the boundary points of the [Range] with another
  /// [Range].
  ///
  /// compare = range.compareBoundaryPoints(how, sourceRange);
  ///
  /// var range, sourceRange, compare;
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div")[0]);
  /// sourceRange = document.createRange();
  /// sourceRange.selectNode(document.getElementsByTagName("div")[1]);
  /// compare = range.compareBoundaryPoints(Range.START_TO_END, sourceRange);
  ///
  int compareBoundaryPoints(int how, Range sourceRange) =>
      js_util.callMethod(this, 'compareBoundaryPoints', [how, sourceRange]);

  /// Removes the contents of a [Range] from the [Document].
  ///
  /// range.deleteContents()
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// range.deleteContents();
  ///
  Object deleteContents() => js_util.callMethod(this, 'deleteContents', []);

  ///  Moves contents of a [Range] from the document tree into a
  /// [DocumentFragment].
  ///
  /// documentFragment = range.extractContents();
  ///
  DocumentFragment extractContents() =>
      js_util.callMethod(this, 'extractContents', []);

  /// Returns a [DocumentFragment] copying the nodes of a [Range].
  ///
  /// documentFragment = range.cloneContents();
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// documentFragment = range.cloneContents();
  /// document.body.appendChild(documentFragment);
  ///
  DocumentFragment cloneContents() =>
      js_util.callMethod(this, 'cloneContents', []);

  /// Insert a [Node] at the start of a [Range].
  ///
  /// range.insertNode(newNode);
  ///
  /// range = document.createRange();
  /// newNode = document.createElement("p");
  /// newNode.appendChild(document.createTextNode("New Node Inserted Here"));
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// range.insertNode(newNode);
  ///
  Object insertNode(Node node) =>
      js_util.callMethod(this, 'insertNode', [node]);

  /// Moves content of a [Range] into a new [Node].
  ///
  /// range.surroundContents(newParent);
  ///
  Object surroundContents(Node newParent) =>
      js_util.callMethod(this, 'surroundContents', [newParent]);

  ///  Returns a [Range] object with boundary points identical to the
  /// cloned [Range].
  ///
  /// clone = range.cloneRange();
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// clone = range.cloneRange();
  ///
  Range cloneRange() => js_util.callMethod(this, 'cloneRange', []);

  /// Releases the [Range] from use to improve performance.
  ///
  /// range.detach();
  ///
  /// var range = document.createRange();
  ///
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// range.detach();
  ///
  Object detach() => js_util.callMethod(this, 'detach', []);

  ///  Returns a [boolean] indicating whether the given point is in the
  /// [Range].
  ///
  /// bool = range.isPointInRange( referenceNode, offset )
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// bool = range.isPointInRange(document.getElementsByTagName("p").item(0),1);
  ///
  @experimental
  bool isPointInRange(Node node, int offset) =>
      js_util.callMethod(this, 'isPointInRange', [node, offset]);

  ///  Returns -1, 0, or 1 indicating whether the point occurs before,
  /// inside, or after the [Range].
  ///
  /// returnValue = range.comparePoint(referenceNode, offset)
  ///
  /// range = document.createRange();
  /// range.selectNode(document.getElementsByTagName('div').item(0));
  /// returnValue = range.comparePoint(document.getElementsByTagName('p').item(0), 1);
  ///
  @experimental
  int comparePoint(Node node, int offset) =>
      js_util.callMethod(this, 'comparePoint', [node, offset]);

  ///  Returns a [boolean] indicating whether the given node intersects
  /// the [Range].
  ///
  /// bool = range.intersectsNode( referenceNode )
  ///
  /// var range = document.createRange();
  ///
  /// range.selectNode(document.getElementsByTagName("div").item(0));
  /// var bool = range.intersectsNode(document.getElementsByTagName("p").item(0));
  ///
  @experimental
  bool intersectsNode(Node node) =>
      js_util.callMethod(this, 'intersectsNode', [node]);

  String mToString() => js_util.callMethod(this, 'toString', []);

  DOMRectList getClientRects() =>
      js_util.callMethod(this, 'getClientRects', []);

  DOMRect getBoundingClientRect() =>
      js_util.callMethod(this, 'getBoundingClientRect', []);

  DocumentFragment createContextualFragment(String fragment) =>
      js_util.callMethod(this, 'createContextualFragment', [fragment]);
}

///
///  The interface
///   represents an iterator over the members of a list of the nodes
/// in a subtree of the
///  DOM. The nodes will be returned in document order.
///
@JS()
@staticInterop
class NodeIterator {
  external NodeIterator();
}

extension PropsNodeIterator on NodeIterator {
  ///
  ///     Returns a [Node] representing the root node as specified when
  /// the
  ///    [NodeIterator] was created.
  ///
  ///
  Node get root => js_util.getProperty(this, 'root');

  /// Returns the [Node] to which the iterator is anchored.
  ///
  @experimental
  Node get referenceNode => js_util.getProperty(this, 'referenceNode');

  ///
  ///    Returns a boolean flag that indicates whether the
  ///    [NodeIterator] is anchored before, the flag being [true],
  ///    or after, the flag being [false], the anchor node.
  ///
  ///
  @experimental
  bool get pointerBeforeReferenceNode =>
      js_util.getProperty(this, 'pointerBeforeReferenceNode');

  ///
  ///    Returns an [unsigned long] being a bitmask made of constants
  ///    describing the types of [Node] that must to be presented.
  ///     Non-matching nodes are skipped, but their children may be
  /// included, if
  ///    relevant.
  ///
  ///   The possible values are:
  ///
  ///
  ///
  ///      Constant
  ///      Numerical value
  ///      Description
  ///
  ///
  ///
  ///
  ///      [NodeFilter.SHOW_ALL]
  ///      [4294967295] (that is the max value of [unsigned long])
  ///      Shows all nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ATTRIBUTE]
  ///
  ///
  ///      [2]
  ///       Shows attribute [Attr] nodes. This is meaningful only when
  /// creating a [NodeIterator] with an [Attr] node as its root; in
  /// this case, it means that the attribute node will appear in the
  /// first position of the iteration or traversal. Since attributes
  /// are never children of other nodes, they do not appear when
  /// traversing over the document tree.
  ///
  ///
  ///      [NodeFilter.SHOW_CDATA_SECTION]
  ///
  ///
  ///      [8]
  ///      Shows [CDATASection] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_COMMENT]
  ///      [128]
  ///      Shows [Comment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT]
  ///      [256]
  ///      Shows [Document] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_FRAGMENT]
  ///      [1024]
  ///      Shows [DocumentFragment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_TYPE]
  ///      [512]
  ///      Shows [DocumentType] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ELEMENT]
  ///      [1]
  ///      Shows [Element] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY]
  ///
  ///
  ///      [32]
  ///      Legacy, no more used.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY_REFERENCE]
  ///
  ///
  ///      [16]
  ///      Legacy, no more used.
  ///
  ///
  ///      [NodeFilter.SHOW_NOTATION]
  ///
  ///
  ///      [2048]
  ///      Legacy, no more used.
  ///
  ///
  ///      [NodeFilter.SHOW_PROCESSING_INSTRUCTION]
  ///      [64]
  ///      Shows [ProcessingInstruction] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_TEXT]
  ///      [4]
  ///      Shows [Text] nodes.
  ///
  ///
  ///
  ///
  int get whatToShow => js_util.getProperty(this, 'whatToShow');

  /// Returns a [NodeFilter] used to select the relevant nodes.
  ///
  NodeFilter? get filter => js_util.getProperty(this, 'filter');

  ///
  ///    Returns the next [Node] in the document, or [null] if
  ///    there are none.
  ///
  ///
  /// node = nodeIterator.nextNode();
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///   false // this optional argument is not used any more
  /// );
  /// currentNode = nodeIterator.nextNode(); // returns the next node
  ///
  Node? nextNode() => js_util.callMethod(this, 'nextNode', []);

  ///
  ///    Returns the previous [Node] in the document, or [null] if
  ///    there are none.
  ///
  ///
  /// node = nodeIterator.previousNode();
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///   false // this optional argument is not used any more
  /// );
  /// currentNode = nodeIterator.nextNode(); // returns the next node
  /// previousNode = nodeIterator.previousNode(); // same result, since we backtracked to the previous node
  ///
  Node? previousNode() => js_util.callMethod(this, 'previousNode', []);

  ///
  ///     This operation is a no-op. It doesn't do anything. Previously
  /// it was telling the
  ///     engine that the [NodeIterator] was no more used, but this is
  /// now
  ///    useless.
  ///
  ///
  /// nodeIterator.detach();
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///   document.body,
  ///   NodeFilter.SHOW_ELEMENT,
  ///   { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
  ///   false
  /// );
  /// nodeIterator.detach(); // detaches the iterator
  ///
  /// nodeIterator.nextNode(); // throws an INVALID_STATE_ERR exception
  ///
  @deprecated
  Object detach() => js_util.callMethod(this, 'detach', []);
}

///  The object represents the nodes of a document subtree and a
/// position within them.
/// A can be created using the [Document.createTreeWalker()] method.
@JS()
@staticInterop
class TreeWalker {
  external TreeWalker();
}

extension PropsTreeWalker on TreeWalker {
  ///  Returns a [Node] representing the root node as specified when
  /// the [TreeWalker] was created.
  ///
  Node get root => js_util.getProperty(this, 'root');

  ///  Returns an [unsigned long] being a bitmask made of constants
  /// describing the types of [Node] that must be presented.
  /// Non-matching nodes are skipped, but their children may be
  /// included, if relevant. The possible values are:
  ///
  ///
  ///
  ///      Constant
  ///      Numerical value
  ///      Description
  ///
  ///
  ///
  ///
  ///      [NodeFilter.SHOW_ALL]
  ///      [4294967295] (that is the max value of [unsigned long])
  ///      Shows all nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ATTRIBUTE]
  ///
  ///
  ///      [2]
  ///       Shows attribute [Attr] nodes. This is meaningful only when
  /// creating a [TreeWalker] with an [Attr] node as its root. In this
  /// case, it means that the attribute node will appear in the first
  /// position of the iteration or traversal. Since attributes are
  /// never children of other nodes, they do not appear when traversing
  /// over the document tree.
  ///
  ///
  ///      [NodeFilter.SHOW_CDATA_SECTION]
  ///
  ///
  ///      [8]
  ///      Shows [CDATASection] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_COMMENT]
  ///      [128]
  ///      Shows [Comment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT]
  ///      [256]
  ///      Shows [Document] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_FRAGMENT]
  ///      [1024]
  ///      Shows [DocumentFragment] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_DOCUMENT_TYPE]
  ///      [512]
  ///      Shows [DocumentType] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ELEMENT]
  ///      [1]
  ///      Shows [Element] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY]
  ///
  ///
  ///      [32]
  ///      Legacy, no more usable.
  ///
  ///
  ///      [NodeFilter.SHOW_ENTITY_REFERENCE]
  ///
  ///
  ///      [16]
  ///      Legacy, no more usable.
  ///
  ///
  ///      [NodeFilter.SHOW_NOTATION]
  ///
  ///
  ///      [2048]
  ///      Legacy, no more usable.
  ///
  ///
  ///      [NodeFilter.SHOW_PROCESSING_INSTRUCTION]
  ///      [64]
  ///      Shows [ProcessingInstruction] nodes.
  ///
  ///
  ///      [NodeFilter.SHOW_TEXT]
  ///      [4]
  ///      Shows [Text] nodes.
  ///
  ///
  ///
  ///
  int get whatToShow => js_util.getProperty(this, 'whatToShow');

  /// Returns a [NodeFilter] used to select the relevant nodes.
  ///
  NodeFilter? get filter => js_util.getProperty(this, 'filter');

  ///  Is the [Node] on which the [TreeWalker] is currently pointing
  /// at.
  ///
  Node get currentNode => js_util.getProperty(this, 'currentNode');
  set currentNode(Node newValue) {
    js_util.setProperty(this, 'currentNode', newValue);
  }

  Node? parentNode() => js_util.callMethod(this, 'parentNode', []);

  Node? firstChild() => js_util.callMethod(this, 'firstChild', []);

  Node? lastChild() => js_util.callMethod(this, 'lastChild', []);

  Node? previousSibling() => js_util.callMethod(this, 'previousSibling', []);

  Node? nextSibling() => js_util.callMethod(this, 'nextSibling', []);

  Node? previousNode() => js_util.callMethod(this, 'previousNode', []);

  Node? nextNode() => js_util.callMethod(this, 'nextNode', []);
}

///  A interface represents an object used to filter the nodes in a
/// [NodeIterator] or [TreeWalker]. A knows nothing about the
/// document or traversing nodes; it only knows how to evaluate a
/// single node against the provided filter.
///
///   Note: The browser doesn't provide any object implementing this
/// interface. It is the user who is expected to write one, tailoring
/// the [acceptNode()] method to its needs, and using it with some
/// [TreeWalker] or [NodeIterator] objects.
///
@JS()
@staticInterop
class NodeFilter {
  external static int get FILTER_ACCEPT;
  external static int get FILTER_REJECT;
  external static int get FILTER_SKIP;
  external static int get SHOW_ALL;
  external static int get SHOW_ELEMENT;
  external static int get SHOW_ATTRIBUTE;
  external static int get SHOW_TEXT;
  external static int get SHOW_CDATA_SECTION;
  external static int get SHOW_ENTITY_REFERENCE;
  external static int get SHOW_ENTITY;
  external static int get SHOW_PROCESSING_INSTRUCTION;
  external static int get SHOW_COMMENT;
  external static int get SHOW_DOCUMENT;
  external static int get SHOW_DOCUMENT_TYPE;
  external static int get SHOW_DOCUMENT_FRAGMENT;
  external static int get SHOW_NOTATION;
  external NodeFilter();
}

extension PropsNodeFilter on NodeFilter {
  ///  Returns an [unsigned short] that will be used to tell if a given
  /// [Node] must be accepted or not by the [NodeIterator] or
  /// [TreeWalker] iteration algorithm.
  ///    This method is expected to be written by the user of a
  /// [NodeFilter]. Possible return values are:
  ///
  ///
  ///
  ///      Constant
  ///      Description
  ///
  ///
  ///
  ///
  ///      [FILTER_ACCEPT]
  ///
  ///       Value returned by the
  ///       [NodeFilter.acceptNode()] method when a node
  ///       should be accepted.
  ///
  ///
  ///
  ///      [FILTER_REJECT]
  ///
  ///
  ///        Value to be returned by the
  ///        [NodeFilter.acceptNode()] method when a
  ///        node should be rejected. For [TreeWalker], child
  ///        nodes are also rejected.
  ///
  ///
  ///        For [NodeIterator], this flag is synonymous
  ///        with [FILTER_SKIP].
  ///
  ///
  ///
  ///
  ///      [FILTER_SKIP]
  ///
  ///
  ///        Value to be returned by
  ///        [NodeFilter.acceptNode()] for nodes to be
  ///        skipped by the [NodeIterator] or
  ///        [TreeWalker] object.
  ///
  ///
  ///         The children of skipped nodes are still considered. This
  /// is treated as
  ///        "skip this node but not its children".
  ///
  ///
  ///
  ///
  ///
  ///
  /// result = nodeFilter.acceptNode(node)
  ///
  /// var nodeIterator = document.createNodeIterator(
  ///  // Node to use as root
  ///  document.getElementById('someId'),
  ///
  ///  // Only consider nodes that are text nodes (nodeType 3)
  ///  NodeFilter.SHOW_TEXT,
  ///
  ///  // Object containing the function to use for the acceptNode method
  ///  // of the NodeFilter
  ///   { acceptNode: function(node) {
  ///    // Logic to determine whether to accept, reject or skip node
  ///    // In this case, only accept nodes that have content
  ///    // other than whitespace
  ///    if ( ! /^\s*$/.test(node.data) ) {
  ///     return NodeFilter.FILTER_ACCEPT;
  ///    }
  ///   }
  ///  },
  ///  false
  /// );
  ///
  /// // Show the content of every non-empty text node that is a child of root
  /// var node;
  ///
  /// while ((node = nodeIterator.nextNode())) {
  ///  alert(node.data);
  /// }
  ///
  int acceptNode(Node node) => js_util.callMethod(this, 'acceptNode', [node]);
}

///  The interface represents a set of space-separated tokens. Such a
/// set is returned by [Element.classList] or
/// [HTMLLinkElement.relList], and many others.
///  A is indexed beginning with [0] as with JavaScript [Array]
/// objects. is always case-sensitive.
@JS()
@staticInterop
class DOMTokenList {
  external DOMTokenList();
}

extension PropsDOMTokenList on DOMTokenList {
  ///  Is an [integer] representing the number of objects stored in the
  /// object.
  ///
  int get length => js_util.getProperty(this, 'length');

  ///  Returns the item in the list by its index, or [undefined] if the
  /// index is greater than or equal to the list's [length].
  ///
  /// tokenList.item(index)
  ///
  String? item(int index) => js_util.callMethod(this, 'item', [index]);

  ///  Returns [true] if the list contains the given token, otherwise
  /// [false].
  ///
  /// contains(token);
  ///
  bool contains(String token) => js_util.callMethod(this, 'contains', [token]);

  /// Adds the specified tokens to the list.
  ///
  /// add(token0);
  /// add(token0, token1);
  /// add(token0, token1, /* ... ,*/ tokenN)
  ///
  Object add([String? tokens]) => js_util.callMethod(this, 'add', [tokens]);

  /// Removes the specified tokens from the list.
  ///
  /// remove(token);
  /// remove(token, token);
  /// remove(token, token, token);
  /// ...
  ///
  Object remove([String? tokens]) =>
      js_util.callMethod(this, 'remove', [tokens]);

  ///  Removes the token from the list if it exists, or adds it to the
  /// list if it doesn't. Returns a boolean indicating whether the
  /// token is in the list after the operation.
  ///
  /// toggle(token);
  /// toggle(token, force);
  ///
  bool toggle(String token, [bool? force]) =>
      js_util.callMethod(this, 'toggle', [token, force]);

  /// Replaces the token with another one.
  ///
  /// replace(oldToken, newToken);
  ///
  bool replace(String token, String newToken) =>
      js_util.callMethod(this, 'replace', [token, newToken]);

  ///  Returns [true] if the given token is in the associated
  /// attribute's supported tokens.
  ///
  /// supports(token);
  ///
  /// const iframe = document.getElementById('display');
  ///
  /// if (iframe.sandbox.supports('an-upcoming-feature')) {
  ///  // support code for mystery future feature
  /// } else {
  ///  // fallback code
  /// }
  ///
  /// if (iframe.sandbox.supports('allow-scripts')) {
  ///  // instruct frame to run JavaScript
  ///  //
  ///  // (NOTE: This feature is well-supported; this is just an example!)
  ///  //
  /// }
  ///
  bool supports(String token) => js_util.callMethod(this, 'supports', [token]);

  ///  A stringifier property that returns the value of the list as a
  /// string.
  ///
  String get value => js_util.getProperty(this, 'value');
  set value(String newValue) {
    js_util.setProperty(this, 'value', newValue);
  }
}

///  The interface represents the results generated by evaluating an
/// XPath expression within the context of a given node.
///  Since XPath expressions can result in a variety of result types,
/// this interface makes it possible to determine and handle the type
/// and value of the result.
@JS()
@staticInterop
class XPathResult {
  external static int get ANY_TYPE;
  external static int get NUMBER_TYPE;
  external static int get STRING_TYPE;
  external static int get BOOLEAN_TYPE;
  external static int get UNORDERED_NODE_ITERATOR_TYPE;
  external static int get ORDERED_NODE_ITERATOR_TYPE;
  external static int get UNORDERED_NODE_SNAPSHOT_TYPE;
  external static int get ORDERED_NODE_SNAPSHOT_TYPE;
  external static int get ANY_UNORDERED_NODE_TYPE;
  external static int get FIRST_ORDERED_NODE_TYPE;
  external XPathResult();
}

extension PropsXPathResult on XPathResult {
  ///  A [number] code representing the type of the result, as defined
  /// by the type constants.
  ///
  int get resultType => js_util.getProperty(this, 'resultType');

  ///  A [number] representing the value of the result if [resultType]
  /// is [NUMBER_TYPE].
  ///
  /* double | NaN */ dynamic get numberValue =>
      js_util.getProperty(this, 'numberValue');

  ///  A [string] representing the value of the result if [resultType]
  /// is [STRING_TYPE].
  ///
  String get stringValue => js_util.getProperty(this, 'stringValue');

  ///  A [boolean] representing the value of the result if [resultType]
  /// is [BOOLEAN_TYPE].
  ///
  bool get booleanValue => js_util.getProperty(this, 'booleanValue');

  ///  A [Node] representing the value of the single node result, which
  /// may be [null].
  ///
  Node? get singleNodeValue => js_util.getProperty(this, 'singleNodeValue');

  ///  Signifies that the iterator has become invalid. It is [true] if
  /// [resultType] is [UNORDERED_NODE_ITERATOR_TYPE] or
  /// [ORDERED_NODE_ITERATOR_TYPE] and the document has been modified
  /// since this result was returned.
  ///
  bool get invalidIteratorState =>
      js_util.getProperty(this, 'invalidIteratorState');

  /// The number of nodes in the result snapshot.
  ///
  int get snapshotLength => js_util.getProperty(this, 'snapshotLength');

  ///  If the result is a node set, this method iterates over it and
  /// returns the next node from it or [null] if there are no more
  /// nodes.
  ///
  /// var node = result.iterateNext();
  ///
  /// The following example shows the use of the iterateNext() method.
  /// <div>XPath example</div>
  /// <div>Tag names of the matched nodes: <output></output></div>
  ///
  /// ```
  ///
  /// var xpath = "//div";
  /// var result = document.evaluate(xpath, document, null, XPathResult.ANY_TYPE, null);
  /// var node = null;
  /// var tagNames = [];
  /// while(node = result.iterateNext()) {
  ///  tagNames.push(node.localName);
  /// }
  /// document.querySelector("output").textContent = tagNames.join(", ");
  ///
  /// ```
  ///
  Node? iterateNext() => js_util.callMethod(this, 'iterateNext', []);

  ///  Returns an item of the snapshot collection or [null] in case the
  /// index is not within the range of nodes. Unlike the iterator
  /// result, the snapshot does not become invalid, but may not
  /// correspond to the current document if it is mutated.
  ///
  /// var node = result.snapshotItem(i);
  ///
  /// The following example shows the use of the snapshotItem() method.
  /// <div>XPath example</div>
  /// <div>Tag names of the matched nodes: <output></output></div>
  ///
  /// ```
  ///
  /// var xpath = "//div";
  /// var result = document.evaluate(xpath, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
  /// var node = null;
  /// var tagNames = [];
  /// for(var i = 0; i < result.snapshotLength; i++) {
  ///  var node = result.snapshotItem(i);
  ///  tagNames.push(node.localName);
  /// }
  /// document.querySelector("output").textContent = tagNames.join(", ");
  ///
  /// ```
  ///
  Node? snapshotItem(int index) =>
      js_util.callMethod(this, 'snapshotItem', [index]);
}

///  This interface is a compiled XPath expression that can be
/// evaluated on a document or specific node to return information
/// from its DOM tree.
///  This is useful when an expression will be reused in an
/// application, because it is just compiled once and all namespace
/// prefixes which occur within the expression are preresolved.
///  Objects of this type are created by calling
/// [XPathEvaluator.createExpression()].
@JS()
@staticInterop
class XPathExpression {
  external XPathExpression();
}

extension PropsXPathExpression on XPathExpression {
  /// Evaluates the XPath expression on the given node or document.
  ///
  /// XPathResult node.evaluate(contextNode, type, result);
  ///
  /// The following example shows the use of the evaluate() method.
  /// <div>XPath example</div>
  /// <div>Number of &lt;div&gt;s: <output></output></div>
  ///
  /// ```
  ///
  /// var xpath = "//div";
  /// var evaluator = new XPathEvaluator();
  /// var expression = evaluator.createExpression("//div");
  /// var result = expression.evaluate(document, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
  /// document.querySelector("output").textContent = result.snapshotLength;
  ///
  /// ```
  ///
  XPathResult evaluate(Node contextNode,
          [int? type = 0, XPathResult? result]) =>
      js_util.callMethod(this, 'evaluate', [contextNode, type, result]);
}

///  The interface permits prefix strings in an XPath expression to
/// be properly bound to namespace URI strings.
///  The [XPathEvaluator] interface can construct an implementation
/// of from a node, or the interface may be implemented by any
/// application.
@JS()
@staticInterop
class XPathNSResolver {
  external XPathNSResolver();
}

extension PropsXPathNSResolver on XPathNSResolver {
  ///  Looks up the namespace URI associated to the given namespace
  /// prefix.
  ///
  /// DOMString XPathNSResolver.lookupNamespaceURI(prefix);
  ///
  String? lookupNamespaceURI(String? prefix) =>
      js_util.callMethod(this, 'lookupNamespaceURI', [prefix]);
}

@JS()
@staticInterop
class XPathEvaluatorBase {
  external XPathEvaluatorBase();
}

extension PropsXPathEvaluatorBase on XPathEvaluatorBase {
  XPathExpression createExpression(String expression,
          [XPathNSResolver? resolver]) =>
      js_util.callMethod(this, 'createExpression', [expression, resolver]);

  XPathNSResolver createNSResolver(Node nodeResolver) =>
      js_util.callMethod(this, 'createNSResolver', [nodeResolver]);

  XPathResult evaluate(String expression, Node contextNode,
          [XPathNSResolver? resolver, int? type = 0, XPathResult? result]) =>
      js_util.callMethod(
          this, 'evaluate', [expression, contextNode, resolver, type, result]);
}

/// The interface allows to compile and evaluate XPath expressions.
/// It is implemented by the [Document] interface.
@JS()
@staticInterop
class XPathEvaluator implements XPathEvaluatorBase {
  external XPathEvaluator();
}

///  Non-standard: This feature is non-standard and is not on a
/// standards track. Do not use it on production sites facing the
/// Web: it will not work for every user. There may also be large
/// incompatibilities between implementations and the behavior may
/// change in the future.Experimental: This is an experimental
/// technologyCheck the Browser compatibility table carefully before
/// using this in production.
///
///   An applies an XSLT stylesheet transformation to an XML document
/// to
///   produce a new XML document as output. It has methods to load
/// the XSLT stylesheet, to
///  manipulate [<xsl:param>] parameter values, and to apply the
///  transformation to documents.
///
@JS()
@staticInterop
class XSLTProcessor {
  external XSLTProcessor();
}

extension PropsXSLTProcessor on XSLTProcessor {
  ///
  ///     Imports the XSLT stylesheet. If the given node is a document
  /// node, you can pass in a
  ///    full XSL Transform or a literal result element
  /// transform; otherwise, it must be an [<xsl:stylesheet>] or
  ///    [<xsl:transform>] element.
  ///
  ///
  Object importStylesheet(Node style) =>
      js_util.callMethod(this, 'importStylesheet', [style]);

  DocumentFragment transformToFragment(Node source, Document output) =>
      js_util.callMethod(this, 'transformToFragment', [source, output]);

  Document transformToDocument(Node source) =>
      js_util.callMethod(this, 'transformToDocument', [source]);

  ///
  ///     Sets a parameter in the XSLT stylesheet that was imported.
  /// (Sets the value of an
  ///    [<xsl:param>].) A null value for [namespaceURI] is treated
  ///    the same as an empty string.
  ///
  ///
  Object setParameter(String namespaceURI, String localName, dynamic value) =>
      js_util
          .callMethod(this, 'setParameter', [namespaceURI, localName, value]);

  ///
  ///     Gets the value of a parameter from the XSLT stylesheet. A
  /// null value for
  ///    [namespaceURI] is treated the same as an empty string.
  ///
  ///
  dynamic getParameter(String namespaceURI, String localName) =>
      js_util.callMethod(this, 'getParameter', [namespaceURI, localName]);

  ///
  ///     Removes the parameter if it was previously set. This will
  /// make the
  ///     [XSLTProcessor] use the default value for the parameter as
  /// specified in the
  ///     stylesheet. A null value for [namespaceURI] is treated the
  /// same as an empty
  ///    string.
  ///
  ///
  Object removeParameter(String namespaceURI, String localName) =>
      js_util.callMethod(this, 'removeParameter', [namespaceURI, localName]);

  ///
  ///    Removes all set parameters from the [XSLTProcessor]. The
  ///     [XSLTProcessor] will then use the defaults specified in the
  /// XSLT
  ///    stylesheet.
  ///
  ///
  Object clearParameters() => js_util.callMethod(this, 'clearParameters', []);

  /// Removes all parameters and stylesheets from the [XSLTProcessor].
  ///
  Object reset() => js_util.callMethod(this, 'reset', []);
}
